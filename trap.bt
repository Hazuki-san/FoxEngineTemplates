// TRAP - GeoTrapFile
// By RLC - inspired by other FOX templates by the researchers of Modders' Heaven!
// https://metalgearmodding.fandom.com/wiki/TRAP
// Special thanks to Joey, BobDoleOwndU and OldBanana!
LittleEndian();

typedef struct
{
    uint hash<format=hex>;
} StrCode32 <read=(hash)>;

typedef struct
{
	float x;
	float y;
	float z;
} Float3 <read=Str("(%g, %g, %g)", x, y, z)>;

typedef struct
{
	float x;
	float y;
	float z;
	float w;
} Float4 <read=Str("(%g, %g, %g, %g)", x, y, z, w)>;

struct Matrix3
{
	float x1;
	float y1;
	float z1;
	float w1;

	float x2;
	float y2;
	float z2;
	float w2;

	float x3;
	float y3;
	float z3;
	float w3;
};

enum <byte> TRAP_SHAPE_TYPE
{
    TRAP_SHAPE_TYPE_BOX_SHAPE = 19,
    TRAP_SHAPE_TYPE_PATH_SHAPE = 27,
};

enum <uint64> Tag
{
	Intrude = 0x1,
	Tower = 0x2,
	InRoom = 0x4,
	FallDeath = 0x8,

	NearCamera1 = 0x10,
	NearCamera2 = 0x20,
	NearCamera3 = 0x40,
	NearCamera4 = 0x80,

	x9978c8d36f7 = 0x100,
	NoRainEffect = 0x200,
	x60e79a58dcc3 = 0x400,
	GimmickNoFulton = 0x800,

	innerZone = 0x1000,
	outerZone = 0x2000,
	hotZone = 0x4000,
	x439898dcbf83 = 0x8000,

	xe780e431a068 = 0x10000,
	x53827eed3fbc = 0x20000,
	x7e1121c5cb93 = 0x40000,
	xcadd57b76a83 = 0x80000,

	xe689072c4df8 = 0x100000,
	x6d14396ebbe5 = 0x200000,
	xd1ee7dc34fff = 0x400000,
	xb07e254afcae = 0x800000,

	xd6ee65d20b7a = 0x10000000,
	xf287ba9cb7e3 = 0x20000000,
	NoFulton = 0x40000000,
	x24330b0e33cb = 0xffffffff80000000,
};

struct
{
    uint VersionDate <hidden = true>; // TPP/SSD is 201406020; February 6th, 2014
	if (VersionDate != 201406020) // if big endian, big endian
	{
		BigEndian();
	}
    uint EntryDefinitionsOffset<hidden = true>; Assert(EntryDefinitionsOffset == 32);
    uint FileSize;
    uint DataSetPathCode32Hash; // PathCode32 hash of the path to the .fox2, same name as the file.
} Header <bgcolor = 0x9EADC8>;

FSeek(Header.EntryDefinitionsOffset);

struct
{
    local uint SelfStartPos = FTell();

	FSkip(8);

	uint Unknown; Assert(Unknown == 1);

	uint OffsetsOffset; Assert(OffsetsOffset == 48);

    uint FileSizePlus16; Assert(FileSizePlus16 == Header.FileSize + 16);
    
    FSkip(16);

    uint EntryCount;

    FSeek(SelfStartPos + OffsetsOffset);

    uint Offsets[EntryCount];
} EntryDefinitions <hidden = true, bgcolor = 0xB9E28C>;

local int i = 0;
for (i = 0; i < EntryDefinitions.EntryCount; i++)
{
    FSeek(EntryDefinitions.SelfStartPos + EntryDefinitions.OffsetsOffset + EntryDefinitions.Offsets[i]);

    struct
    {
        uint ShapeType : 8;
	    uint ShapeDefinition1 : 8;
	    uint ShapeDefinition2 : 8;
	    uint ShapeCount : 8;
    
	    FSkip(12);
    
        Tag tag<format=binary>;
	    
	    StrCode32 EntryNameHash;	
    
	    FSkip(4);
	    
	    if (ShapeType == TRAP_SHAPE_TYPE_BOX_SHAPE)
	    {
		    struct BoxShape
		    {
			    Float4 scale;	// I seem to remember Intrude triggers needing to be scaled up by two, but I don't remember if it applies to all boxes
			    
			    FSkip(16);
			    
			    Matrix3 Rotation;
			    
			    Float4 Translation;
			    
		    } Shapes[ShapeCount];
	    }
	    else if (ShapeType == TRAP_SHAPE_TYPE_PATH_SHAPE)
	    {
		    struct PathShape
		    {
                local uint SelfStartPos = FTell();
    
			    float YMinimum;
			    float YMaximum;
			    uint PointCount;
			    uint PointsDataOffset;
    
                FSeek(SelfStartPos + PointsDataOffset);
			    
			    Float4 Points[PointCount];
		    } Shapes[ShapeCount] <optimize = false>;
	    }
	    else
	    {
		    Assert(false, "Unknown Shape!");
	    };
    } Entry <optimize = false, bgcolor = 0xD6D84F>;
}
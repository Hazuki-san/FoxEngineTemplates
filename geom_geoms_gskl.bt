LittleEndian();

#include "common/common.bt"
#include "geo/geo_common.bt"

#define COLOR_HEADER 0xDFEFAA
#define COLOR_ENTRY 0x7DE39E
#define COLOR_ENTRYBVHSECTION 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_ENTRYMATERIALSECTION 0xB9E8DD
#define COLOR_BOUNDINGBOXCHUNK 0xF7F205

typedef struct
{
	local long SelfStartPos = FTell();

	GeomHeader Header(GEO_FILE_TYPE_GEOM_GEOMS_GSKL);

	switch (Header.Type)
	{
	case GEO_COLLISION_SHAPE_TYPE_AABB:
		GeoPrimAabb Prim[Header.PrimCount] <optimize = true>;
		break;
	case GEO_COLLISION_SHAPE_TYPE_QUAD:
		GeoPrimQuad Prim[Header.PrimCount] <optimize = true>;
		break;
	default:
        Assert(false, "Unknown CollisonShape type detected!");
	}

	// if ((Header.VertexBufferOffset & 0xfffffff) != 0)
	// 	{
	// 		FSeek(SelfStartPos + Header.VertexBufferOffset * 16);

	// 		struct GeoVertexHeader
	// 		{
	// 			uint VertexCount;
	// 			uint VerticesIndexOffset;

	// 			uint Unknown0Or1; Assert(Unknown0Or1 == 0 || Unknown0Or1 == 1);

	// 			uint OriginIndex;

	// 			int64 VertexDataOffset; // This gets patched at runtime to use a FMDL pointer.
				
	// 			uint FmdlVertexBufferOffset;

	// 			uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	// 		} VertexHeader; // Name taken from PES RTTI

	// 		// mgsvtpp.exe!141bd7e9c
	// 		if ((Header.Flags & GEO_COLLISION_SHAPE_FLAGS_USE_FMDL_VERTEX_DATA) == 0)
	// 		{
	// 			WideVector3 VertexData[VertexHeader.VertexCount] <optimize = true>;

	// 			// origin = VertexData[VertexHeader.OriginIndex]
	// 			// A: VertexData[VertexHeader.VerticesIndexOffset + IndexSet.Offset0] + origin
	// 			// B: VertexData[VertexHeader.VerticesIndexOffset + IndexSet.Offset1] + origin
	// 			// C: VertexData[VertexHeader.VerticesIndexOffset + IndexSet.Offset2] + origin
	// 			// D: VertexData[VertexHeader.VerticesIndexOffset + IndexSet.Offset3] + origin
	// 		}
	// 		else if (VertexHeader.VertexDataOffset == 0 && false /* FMDL vertex pointer is null*/)
	// 		{
	// 			// A: WideVector3(0, -10000, 0, 0)
	// 			// B: WideVector3(0, -10000, 1, 0)
	// 			// C: WideVector3(1, -10000, 1, 0)
	// 			// D: WideVector3(1, -10000, 0, 0)
	// 		}
	// 		else
	// 		{
	// 			// VertexData points to the VertexHeader.FmdlVertexBufferOffset-adjusted fmdl data.
	// 			// A: VertexData[IndexSet.Offset0]
	// 			// B: VertexData[IndexSet.Offset1]
	// 			// C: VertexData[IndexSet.Offset2]
	// 			// D: VertexData[IndexSet.Offset3]
	// 		}
	// 	}
} GeoShape <read=Str("%s, %d", EnumToString(this.Header.Type), this.Header.Flags)>;

struct GeoBlock  // Name taken from PES RTTI
{
	byte IsFinalEntry;

	byte ShapesTotalSizeInEntries; // Includes the "null terminator" entry
	ushort ShapeDataSize;
	
	short LastHeaderOffsetMaybe;
	short Padding0; Assert(Padding0 == 0);
	
	short FirstHeaderOffsetMaybe;
	short Padding1; Assert(Padding1 == 0);
	
	uint VertexBufferOffset;

	uint RootAABBHeaderOffset; // Confirmed via PES executable; always points to AABB GeoShape

	uint NextSectionOffset;
	
	GEO_COL_A Tags;
	
	FSeek(SelfStartPos + RootAABBHeaderOffset);

	// I'm going to have to stare at this for longer to understand what the heck is going on here.
	struct
	{
		local uint64 ptrs[6];
		ptrs[0] = SelfStartPos + RootAABBHeaderOffset;
		local uint j = 1;
		local uint j_minusOne;
		local int iteratorIndex = 0;
		local int iteratorIndex_minusOne;
		local uint64 ptr;

		do
		{
			ptr = ptrs[iteratorIndex];

			j_minusOne = j - 1;
			iteratorIndex_minusOne = iteratorIndex - 1;

			FSeek(ptr + 4);
			if (ReadUInt() != 0) // if (Data.Header.NextBBDataChunkOffset != 0)
			{
				ptrs[j - 1] = ptr + ReadUInt() * 16;

				j_minusOne = j;
				iteratorIndex_minusOne = iteratorIndex;
			}
		
			j = j_minusOne;
			iteratorIndex = iteratorIndex_minusOne;
			FSeek(ptr);
			if ((ReadUInt() & 0x200) == 0) // if (Data.Header.Info.Flags & GEO_COLLISION_SHAPE_FLAGS_NO_PAYLOAD == 0)
			{
				GeoShape Shape;

				if (Shape.Header.ChildHeaderOffset != 0)
				{
					if (true)
					{
						j = j_minusOne + 1;
						iteratorIndex = iteratorIndex_minusOne + 1;
						ptrs[j_minusOne] = ptr + Shape.Header.ChildHeaderOffset * 16;
					}
				}
			}
		} while (j > 0);
	} GeoShapes;
	
	FSeek(SelfStartPos + VertexBufferOffset);

	GeoVertexHeader VertexHeader;
};

struct GeoBlocks
{
    local uint SelfStartPos;
    local uint i;
	local uint nextBBChunkPos;

    while(!ReadUByte())
	{
        SelfStartPos = FTell();

		GeoBlock Block;

        FSeek(SelfStartPos + 32);
	};

	// Skip last "dummy" data chunk definition
    FSkip(32);
};

struct GeoMaterialHeader // Name taken from PES RTTI
{
	byte MaterialsOffsetInEntries; // Confirmed via PES
	byte MaterialsTotalSizeInEntries; // Presumptive; includes "null terminator entry"
	byte AuxMaterialsOffsetInEntries; // Confirmed via PES
	byte AuxMaterialsTotalSizeInEntries; // Presumptive; includes "null terminator entry"
};

struct GeoMaterial
{
	GeoNameHash Name;

	uint64 LikelyPtrPlaceholder; Assert(LikelyPtrPlaceholder == 0); // The PES .so has a concept of a MaterialDatabase. 
																	// The hash likely gets resolved at runtime into a permanent pointer to the material and stored here
};

struct GeoMaterials
{
	GeoMaterialHeader Header; 

	local int64 MaterialsStartPos = FTell();

	FSeek(MaterialsStartPos + Header.MaterialsOffsetInEntries * 12 /*sizeof(GeoMaterial)*/);
	
	while (ReadUInt() != 0)
    {
		GeoMaterial Material;
    }

	FSkip(12 /*sizeof(GeoMaterial)*/);

	FSeek(MaterialsStartPos + Header.AuxMaterialsOffsetInEntries * 12 /*sizeof(GeoMaterial)*/);
	
	while (ReadUInt() != 0)
    {
		GeoMaterial Material;
    }

	FSkip(12 /*sizeof(GeoMaterial)*/);

	FAlign(16);
};

struct GeoBoundingVolume
{
	Vector3 BoundingBoxCorner; // Mysterious. mgsvtpp.exe!141b95c89

	ushort GridTotalDataSize;
	ushort GeoBlockCount;

	Vector3 BoundingBoxExtents;

	uint NextSectionOffset;

	Vector3 GridSize;
	
	uint CellCountX;
	uint CellCountY;
	uint CellCountZ;
	
	GEO_COL_A Tags;
	
	struct
	{
		short NodeOffsets[CellCountX * CellCountY * CellCountZ] <hidden = true>;

		local uint i;
		local uint j;
		for (i = 0; i < CellCountX * CellCountY * CellCountZ; i++)
		{
			if (NodeOffsets[i] != -1)
			{
				FSeek(startof(parentof(this)) + NodeOffsets[i]);

				struct
				{
					ushort BlockCount <hidden = true>;
					for (j = 0; j < BlockCount; j++)
						ushort BlockIndex;
				} Cell;
			}
			else
			{
				struct
				{
				} Cell;
			}
		}
	} Cells;
};

// mgsvtpp.exe!14cd19a40

FoxDataHeader Header; // mgsvtpp.exe!141bef7b2

FSeek(Header.NodesOffset);

FoxDataNodes Nodes;

local uint nodeIndex = 0; // As far as I can tell, 010 doesn't let us recursively define structs so the array is Node, Child, Node, Child instead of Node     , Node     etc.
			      		  // 																														  - Child    - Child
local uint childIndex = 0;
do
{
	if (Nodes.Node[nodeIndex].ChildNodeOffset == 0)
	{
		nodeIndex++;
		break;
	}
	
	FSeek(startof(Nodes.Child[childIndex]) + Nodes.Child[childIndex].DataOffset);
	
	struct
	{
		if (Nodes.Child[childIndex].Flags == 0)
		{
			GeoBoundingVolume BoundingVolume <bgcolor = COLOR_ENTRYBVHSECTION>;
		
			FSeek(startof(BoundingVolume) + BoundingVolume.NextSectionOffset);
		}

		GeoBlocks Blocks <bgcolor = COLOR_CHUNK11>;
		
		GeoMaterials Materials <bgcolor = COLOR_ENTRYMATERIALSECTION>;
	} GeoGroup; // The PES .so deals with a GeoGroup structure that has a grid and owns a list of GeoBlocks, but the layout is sort of different. It seems like it's a sort of proto-BVH section 
	
	nodeIndex++;
	childIndex++;
} while(exists(Nodes.Node[nodeIndex]));
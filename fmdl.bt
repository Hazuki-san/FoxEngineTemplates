LittleEndian();

#include "common/common.bt"

#define COLOR_Header 0xDFEFAA
#define COLOR_FeatureHeader 0x7DE39E
#define COLOR_BufferHeader 0x00AAFF
#define COLOR_FmdlBoneUnit 0xAED2E8
#define COLOR_FmdlMeshGroupHeader 0xB9E8DD
#define COLOR_FmdlMeshGroupDef 0xF7F205
#define COLOR_FmdlMeshUnit 0x763765
#define COLOR_FmdlMaterialInstanceHeader 0x3C8D86
#define COLOR_FmdlBoneGroup 0x8A9872
#define COLOR_FmdlTextureRefUnit 0xED688E
#define COLOR_FmdlMaterialParameter 0x7C706F
#define COLOR_FmdlMaterialPlatformAliasUnit 0x939FC8
#define COLOR_FmdlMeshFormatDesc 0x000080
#define COLOR_FmdlMeshFormatElement 0x008000
#define COLOR_FmdlVertexFormatElement 0x008080
#define COLOR_FmdlStringHeader 0x800000
#define COLOR_AABB 0x800080
#define COLOR_FmdlMeshBufferHeader 0x808000
#define COLOR_FmdlLodInfo 0x808080
#define COLOR_FmdlVBufferSlice 0x000040
#define COLOR_FmdlType18 0x0000c0
#define COLOR_FmdlType20 0x008040
#define COLOR_PathCode64 0x0080c0
#define COLOR_StrCode 0x800040
#define COLOR_FmdlMaterialParameterVector 0x8000c0


#define COLOR_Vertices 0x00c0c0
#define COLOR_BoneWeights 0x808040
#define COLOR_Normals 0x8080c0
#define COLOR_Colors 0x004000
#define COLOR_BoneIndices 0x004080
#define COLOR_Uv1 0x804000
#define COLOR_Uv2 0x804080
#define COLOR_Uv3 0x80c000
#define COLOR_Uv4 0x80c080
#define COLOR_UnknownWeights 0x004040
#define COLOR_UnknownIndices 0x0040c0
#define COLOR_Tangents 0x00c040
#define COLOR_Triangles 0x804040

enum <ubyte> FMDL_FEATURE_TYPE
{
	FMDL_FEATURE_TYPE_BONE_UNITS = 0,
	FMDL_FEATURE_TYPE_MESH_GROUP_HEADERS = 1,
	FMDL_FEATURE_TYPE_MESH_GROUP_DEFS = 2,
	FMDL_FEATURE_TYPE_MESH = 3,
	FMDL_FEATURE_TYPE_MATERIAL_INSTANCE_HEADERS = 4,
	FMDL_FEATURE_TYPE_BONE_GROUP = 5,
	FMDL_FEATURE_TYPE_TEXTURE_REFS = 6,
	FMDL_FEATURE_TYPE_MATERIAL_PARAMS = 7,
	FMDL_FEATURE_TYPE_MATERIAL_PLATFORM_ALIASES = 8,
	FMDL_FEATURE_TYPE_MESH_FORMAT_DESCS = 9,
	FMDL_FEATURE_TYPE_MESH_FORMAT_ELEMENTS = 10,
	FMDL_FEATURE_TYPE_VERTEX_FORMAT_ELEMENTS = 11,
	FMDL_FEATURE_TYPE_STRING_HEADER = 12,
	FMDL_FEATURE_TYPE_AABBS = 13,
	FMDL_FEATURE_TYPE_VBUFFER_HEADERS = 14,
	FMDL_FEATURE_TYPE_LOD_INFO = 16,
	FMDL_FEATURE_TYPE_FACE_INFOS = 17,
	FMDL_FEATURE_TYPE_UNK_18 = 18,
	FMDL_FEATURE_TYPE_UNK_19 = 19,
	FMDL_FEATURE_TYPE_UNK_20 = 20,
	FMDL_FEATURE_TYPE_PATH_HASHES = 21,
	FMDL_FEATURE_TYPE_NAME_HASHES = 22,
};

enum <uint> FMDL_BUFFER_TYPE
{
	FMDL_BUFFER_TYPE_MATERIAL_PARAMS = 0,
	FMDL_BUFFER_TYPE_VERTICES = 2,
	FMDL_BUFFER_TYPE_STRINGS = 3
};

typedef struct
{
	FMDL_FEATURE_TYPE Type;
	ubyte CountOverflow;
	ushort EntryCount; // Entry count == CountOverflow * (UINT16_MAX + 1) + EntryCount
	uint DataOffset;
} FeatureHeader <optimize = false, bgcolor = COLOR_FeatureHeader>;
uint GetFeatureEntryCount(FeatureHeader& header)
{
	return (uint)header.CountOverflow * 0x10000 + header.EntryCount;
}

typedef struct
{
	FMDL_BUFFER_TYPE Type;
	uint DataOffset;
	uint DataSize;
} BufferHeader <bgcolor = COLOR_BufferHeader>;

typedef ushort _NameIndex;
typedef ushort _PathIndex;

struct FMDL_BONE_FLAGS
{
	byte A : 1;
	byte B : 1;
	byte   : 6;
};

typedef struct
{
	_NameIndex NameIndex;
	short ParentIndex;
	ushort AABBIndex;
	FMDL_BONE_FLAGS Flags;
	ubyte FlagPadding <hidden = true>; Assert(FlagPadding == 0);
	FSkip(8);
	Vector4 LocalPosition;
	Vector4 WorldPosition;
} FmdlBoneUnit <optimize = false, bgcolor = COLOR_FmdlBoneUnit>;

struct FMDL_MESH_GROUP_HEADER_FLAGS
{
	byte Invisible : 1;
	byte A		   : 1;
	byte B		   : 1;
	byte		   : 5;
};

typedef struct
{
	_NameIndex NameIndex;
	FMDL_MESH_GROUP_HEADER_FLAGS Flags;
	ubyte FlagPadding <hidden = true>; Assert(FlagPadding == 0);
	short ParentIndex;
	short Unknown0; Assert(Unknown0 == -1); // Not read by the game.
} FmdlMeshGroupHeader <optimize = false, bgcolor = COLOR_FmdlMeshGroupHeader>;

typedef struct
{
	FSkip(4);
	ushort MeshGroupHeaderIndex;
	ushort MeshCount;
	ushort MeshesStartIndex;
	ushort MeshFormatDescIndexOrAABBIndex;
	FSkip(4);
	ushort VBufferSlicesStartIndex;
	FSkip(0xE);
} FmdlMeshGroupDef <optimize = true, bgcolor = COLOR_FmdlMeshGroupDef>;

typedef struct
{
	uint StartIndex;
	uint Count;
} FmdlVBufferSlice <optimize = true, bgcolor = COLOR_FmdlVBufferSlice>;

typedef struct
{
	// byte AlphaEnum;
	// byte ShadowEnum;
	// byte UnknownEnum0;
	// byte UnknownEnum1; //Used by net fmdls in PES

	// >> 10, >> 13
	uint Flags;

	ushort MaterialInstanceIndex;
	ushort BoneGroupIndex;
	ushort MeshGroupIndex; // No
	ushort VertexCount;
	FSkip(4);
	FmdlVBufferSlice Slice;
	uint VBufferSlicesStartIndex; // Only actually used if some EXE byte says to use multiple slices. Each slice's StartIndex is relative to the main slice.
	FSkip(0x14);
} FmdlMeshUnit <optimize = true, bgcolor = COLOR_FmdlMeshUnit>;

typedef struct
{
	_NameIndex NameIndex;
	FSkip(2);
	_NameIndex MaterialIndex;
	byte TextureParamCount;
	byte VectorParamCount;
	ushort TextureParamsStartIndex;
	ushort VectorParamsStartIndex;
	FSkip(4);
} FmdlMaterialInstanceHeader <optimize = true, bgcolor = COLOR_FmdlMaterialInstanceHeader>;

typedef struct
{
	ushort Unknown0;
	ushort BoneIndexCount; Assert(Unknown0 <= BoneIndexCount);
	ushort BoneIndices[BoneIndexCount];
	FSkip(0x40 - BoneIndexCount * sizeof(ushort));
} FmdlBoneGroup <optimize = false, bgcolor = COLOR_FmdlBoneGroup>;

typedef struct
{
	_NameIndex NameIndex; // For "/Assets/path/name.ftex" this is StrCode("name") if TPP or just "name.ext" (ext can be tga, psd, etc.) if GZ
	_PathIndex PathIndex; // For "/Assets/path/name.ftex" this is PathCode64("/Assets/path/name.ftex") if TPP or just "/Assets/path/" if GZ
} FmdlTextureRefUnit <optimize = true, bgcolor = COLOR_FmdlTextureRefUnit>;

typedef struct
{
	_NameIndex ParamNameIndex;
	ushort ReferenceIndex; // Can be either a path index to a .ftex or an index into the material params buffer 
} FmdlMaterialParameter <optimize = true, bgcolor = COLOR_FmdlMaterialParameter>;

typedef struct
{
	_NameIndex TypeNameIndex;
	_NameIndex TechniqueNameIndex;
} FmdlMaterialPlatformAliasUnit <optimize = true, bgcolor = COLOR_FmdlMaterialPlatformAliasUnit>;

typedef struct
{
	byte ElementCount;
	byte VertexFormatCount;
	byte Unknown0; Assert(Unknown0 == 0); //Possibly the first UV set's index.
	byte UvCount;
	ushort MeshFormatElementsStartIndex;
	ushort VertexFormatsStartIndex;
} FmdlMeshFormatDesc <optimize = false, bgcolor = COLOR_FmdlMeshFormatDesc>;

typedef struct
{
	byte MeshBufferHeaderIndex;
	byte VertexFormatCount;
	byte Stride;
	byte Type;
	uint Offset;
} FmdlMeshFormatElement <optimize = true, bgcolor = COLOR_FmdlMeshFormatElement>;

typedef struct
{
	byte Type;
	byte DataType;
	ushort Offset;
} FmdlVertexFormatElement <optimize = true, bgcolor = COLOR_FmdlVertexFormatElement>;

typedef struct
{
	ushort BufferType; Assert(BufferType == FMDL_BUFFER_TYPE_STRINGS);
	ushort Length;
	uint Offset;
} FmdlStringHeader <read = ReadString(Header.BuffersDataOffset + BufferHeaders[_BufferIndices[BufferType]].DataOffset + Offset, Length), optimize = false, bgcolor = COLOR_FmdlStringHeader>;

enum <uint> FMDL_MESH_BUFFER_TYPE
{
	FMDL_MESH_BUFFER_TYPE_VBUFFER = 0,
	FMDL_MESH_BUFFER_TYPE_INDEX_BUFFER = 1,
};

typedef struct
{
	FMDL_MESH_BUFFER_TYPE Type;
	uint DataSize;
	uint DataOffset;
	FSkip(4);
} FmdlMeshBufferHeader <optimize = false, bgcolor = COLOR_FmdlMeshBufferHeader>;

typedef struct
{
	uint lodCount;
	float unknown0;
	float unknown1;
	float unknown2;
} FmdlLodInfo <optimize = true, bgcolor = COLOR_FmdlLodInfo>;

typedef struct
{
	uint64 unknown0; //Always 0.
} FmdlType18 <optimize = true, bgcolor = COLOR_FmdlType18>;

typedef struct
{
	FSkip(4);
	float unknown0; //Nulling triggers lowest LOD faces.
	float unknown1;
	float unknown2;
	float unknown3; //Always a whole number?

	uint unknown4;
	uint unknown5;
	int unknown6;

	uint unknownBoolLike <read = ((this == 0) + 3)>;

	FSkip(0x5C);
} FmdlType20 <optimize = true, bgcolor = COLOR_FmdlType20>;

struct Triangles(int i)
{
	ushort triangles[FmdlMeshUnits[i].faceVertexCount];
};
 
struct FmdlMeshAttributes 
{
	local int h;
	local int position = FTell();

	for (h = FmdlMeshFormatDescs[i].firstVertexFormatIndex; h < FmdlMeshFormatDescs[i].firstVertexFormatIndex + FmdlMeshFormatDescs[i].vertexFormatCount; h++)
	{
		FSeek(position + fmdlVertexFormats[h].offset);
		switch (fmdlVertexFormats[h].type)
		{
			case 0:
				break;
			case 1:
				VectorB4 boneWeights <bgcolor=COLOR_BoneWeights>;
				break;
			case 2:
				VectorH4 normals <bgcolor=COLOR_Normals>;
				break;
			case 3:
				VectorB4 colors <bgcolor=COLOR_Colors>;
				break;
			case 7:
				VectorB4 boneIndices <bgcolor=COLOR_BoneIndices>;
				break;
			case 8:
				VectorH2 uv1 <bgcolor=COLOR_Uv1>;
				break;
			case 9:
				VectorH2 uv2 <bgcolor=COLOR_Uv2>;
				break;
			case 0xA:
				VectorH2 uv3 <bgcolor=COLOR_Uv3>;
				break;
			case 0xB:
				VectorH2 uv4 <bgcolor=COLOR_Uv4>;
				break;
			case 0xC:
				VectorB4 unknownWeights <bgcolor=COLOR_UnknownWeights>;
				break;
			case 0xD:
				VectorB4 unknownIndices <bgcolor=COLOR_UnknownIndices>;
				break;
			case 0xE:
				VectorH4 tangents <bgcolor=COLOR_Tangents>;
				break;
			default:
				Printf("Unknown Case");
				break;
		} //switch
	}//for
	FSeek(position + fmdlMeshFormats[FmdlMeshFormatDescs[i].firstMeshFormatIndex + 1].length);
};

struct FmdlMesh(int i) 
{
	FSeek(header.section1Offset + section1Infos[bufferIndex].offset + FmdlMeshBufferHeaders[0].offset + fmdlMeshFormats[FmdlMeshFormatDescs[i].firstMeshFormatIndex].offset);
	Vector3 vertices[FmdlMeshUnits[i].vertexCount] <bgcolor=COLOR_Vertices, optimize=true>;
	FSeek(header.section1Offset + section1Infos[bufferIndex].offset + FmdlMeshBufferHeaders[1].offset + fmdlMeshFormats[FmdlMeshFormatDescs[i].firstMeshFormatIndex + 1].offset);
	
	FmdlMeshAttributes fmdlMeshAttributes[FmdlMeshUnits[i].vertexCount] <optimize=true>;;
	FSeek(header.section1Offset + section1Infos[bufferIndex].offset + FmdlMeshBufferHeaders[2].offset + FmdlMeshUnits[i].firstFaceVertexIndex * 2);
	Triangles triangles(i) <bgcolor=COLOR_Triangles, optimize=true>;
};

struct FmdlMeshes 
{
	local int i;
	for (i = 0; i < section0Infos[meshInfoIndex].entryCount; i++)
	{
		FmdlMesh fmdlMesh(i);
	}
};

struct FmdlHeader
{
	char Signature[4]; Assert(Signature == "FMDL");

	float Version; Assert(Version == 2.03f || Version == 2.04f);

	uint FileDescOffset;
	uint Padding0 <hidden = true>; Assert(Padding0 == 0);

	uint FeatureTypes <read = ((FMDL_FEATURE_TYPE)this)>;
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);

	uint BufferTypes <read = ((FMDL_BUFFER_TYPE)this)>;
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	
	uint FeatureCount;
	uint BufferCount;
	uint FeaturesDataOffset;
	uint FeaturesDataSize;
	uint BuffersDataOffset;
	uint BuffersDataSize;
} Header <bgcolor=COLOR_Header>;

FSeek(Header.FileDescOffset);

// FileDesc
FeatureHeader FeatureHeaders[Header.FeatureCount] <bgcolor = COLOR_FeatureHeader>;

local int _FeatureIndices[23];
local int fFit;
local int fIdx;
local int rFIdx;
for (fIdx = 0, rFIdx = 0, fFit = 1; fIdx < 23; fIdx++, fFit = fFit << 1 | ((int)fFit < 0))
	_FeatureIndices[fIdx] = ((Header.FeatureTypes & fFit) == 0) ? -1 : rFIdx++;

BufferHeader BufferHeaders[Header.BufferCount] <bgcolor = COLOR_BufferHeader>;

local int _BufferIndices[4];
local int bFit;
local int bIdx;
local int rBIdx;
for (bIdx = 0, rBIdx = 0, bFit = 1; bIdx < 4; bIdx++, bFit = bFit << 1 | ((int)bFit < 0))
	_BufferIndices[bIdx] = ((Header.BufferTypes & bFit) == 0) ? -1 : rBIdx++;

// Features
if (_FeatureIndices[FMDL_FEATURE_TYPE_BONE_UNITS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_BONE_UNITS]].DataOffset);
	FmdlBoneUnit Bones[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_BONE_UNITS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_MESH_GROUP_HEADERS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_GROUP_HEADERS]].DataOffset);
	FmdlMeshGroupHeader MeshGroupHeaders[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_GROUP_HEADERS]])];
}
/**/
if (_FeatureIndices[FMDL_FEATURE_TYPE_MESH_GROUP_DEFS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_GROUP_DEFS]].DataOffset);
	FmdlMeshGroupDef MeshGroupDefs[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_GROUP_DEFS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_MESH] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH]].DataOffset);
	FmdlMeshUnit Meshes[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_INSTANCE_HEADERS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_INSTANCE_HEADERS]].DataOffset);
	FmdlMaterialInstanceHeader MaterialInstances[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_INSTANCE_HEADERS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_BONE_GROUP] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_BONE_GROUP]].DataOffset);
	FmdlBoneGroup BoneGroups[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_BONE_GROUP]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_TEXTURE_REFS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_TEXTURE_REFS]].DataOffset);
	FmdlTextureRefUnit TexturesRefs[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_TEXTURE_REFS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_PARAMS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_PARAMS]].DataOffset);
	FmdlMaterialParameter MaterialParameters[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_PARAMS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_PLATFORM_ALIASES] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_PLATFORM_ALIASES]].DataOffset);
	FmdlMaterialPlatformAliasUnit MaterialAliases[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MATERIAL_PLATFORM_ALIASES]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_MESH_FORMAT_DESCS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_FORMAT_DESCS]].DataOffset);
	FmdlMeshFormatDesc MeshFormatDescs[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_FORMAT_DESCS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_MESH_FORMAT_ELEMENTS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_FORMAT_ELEMENTS]].DataOffset);
	FmdlMeshFormatElement MeshFormatElements[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_MESH_FORMAT_ELEMENTS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_VERTEX_FORMAT_ELEMENTS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_VERTEX_FORMAT_ELEMENTS]].DataOffset);
	FmdlVertexFormatElement VertexFormatElements[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_VERTEX_FORMAT_ELEMENTS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_STRING_HEADER] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_STRING_HEADER]].DataOffset);
	FmdlStringHeader StringHeaders[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_STRING_HEADER]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_AABBS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_AABBS]].DataOffset);
	AABB AABBs[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_AABBS]])] <bgcolor = COLOR_AABB>;
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_VBUFFER_HEADERS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_VBUFFER_HEADERS]].DataOffset);
	FmdlMeshBufferHeader MeshBufferHeaders[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_VBUFFER_HEADERS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_LOD_INFO] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_LOD_INFO]].DataOffset);
	FmdlLodInfo LodInfo; Assert(GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_LOD_INFO]]) == 1);
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_FACE_INFOS] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_FACE_INFOS]].DataOffset);
	FmdlVBufferSlice FaceInfos[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_FACE_INFOS]])];
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_UNK_18] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_UNK_18]].DataOffset);
	FmdlType18 Type18; Assert(GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_UNK_18]]) == 1);
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_UNK_20] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_UNK_20]].DataOffset);
	FmdlType20 Type20; Assert(GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_UNK_20]]) == 1);
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_PATH_HASHES] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_PATH_HASHES]].DataOffset);
	PathCode64 Paths[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_PATH_HASHES]])] <bgcolor = COLOR_PathCode64>;
}
if (_FeatureIndices[FMDL_FEATURE_TYPE_NAME_HASHES] != -1)
{
	FSeek(Header.FeaturesDataOffset + FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_NAME_HASHES]].DataOffset);
	StrCode Names[GetFeatureEntryCount(FeatureHeaders[_FeatureIndices[FMDL_FEATURE_TYPE_NAME_HASHES]])] <bgcolor = COLOR_StrCode>;
}
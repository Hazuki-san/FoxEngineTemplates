LittleEndian();

void AlignRead(int alignment)
{
    local long alignmentRequired = FTell() % alignment;
    if (alignmentRequired > 0)
        FSeek(FTell() + alignment - alignmentRequired);
}

typedef struct
{
    uint hash<format=hex>;
} StrCode32 <read=(hash)>;

typedef struct
{
    hfloat r;
    hfloat g;
    hfloat b;
    hfloat skyVisibility;
} ShCoefficients <read=Str("(%f, %f, %f, %f)", r, g, b, skyVisibility)>;

struct ShCoefficientSet
{
    ShCoefficients coefficients[9];
};

typedef struct
{
    ushort VariableType; // 0: uint, 2: float
    ushort NextMetadataOffset; //sizeof(HeaderMetadata0) or 0
    StrCode32 NameHash;
    uint NameStringOffset;
    float Value;
} FloatMetadata <read=Str("(%s, %f)", HashLookup(NameHash), Value)>;

typedef struct
{
    ushort VariableType; // 0: uint, 2: float
    ushort NextMetadataOffset; // sizeof(HeaderMetadata0) or 0
    StrCode32 NameHash;
    uint NameStringOffset;
    uint Value;
} UIntMetadata <read=Str("(%s, %d)", HashLookup(NameHash), Value)>;

typedef struct
{
    local uint SelfStartPos = FTell();

    StrCode32 NameHash <read=HashLookup(this)>; // 0 in OBR Type==3 ObjectBrush entry
    uint NameStringOffsetRelative;
    uint Unknown<hidden=true>; // Only nonzero in HTRE Type==4 files and OBR Type==3 files
    uint DataOffset; // 0 means no data
    uint DataSize; // 0 means no data
    uint EditParamOffset; Assert(EditParamOffset == 0);             // Only nonzero for configrationIds entry in HTRE Type==3 files
    uint ConfigrationIdsOffset; Assert(ConfigrationIdsOffset == 0); // exe searches for this entry, Only nonzero for editParam entry in HTRE Type==3 files
    int PreviousEntryOffset; // 0 means no previous entries
    int NextEntryOffset; // 0 means no more entries
    uint ScalarSubParamOffset; // 0 means no subparams
    uint padding2<hidden=true>; Assert(padding2 == 0);
    uint padding3<hidden=true>; Assert(padding3 == 0);
} SectionMetadata <read=Str("%s", HashLookup(NameHash))>;

struct
{
    uint Type;
    uint FirstSectionOffset; Assert(FirstSectionOffset == 0x20);
    uint FileSize;
    StrCode32 NameHash <read=HashLookup(this)>;
    uint NameStringOffset;
} Header<bgcolor=0xaaaaaa>;

FSeek(Header.FirstSectionOffset);

struct
{
    SectionMetadata LightProbeSHCoefficientsDefinition;
    FSeek(LightProbeSHCoefficientsDefinition.SelfStartPos);
    FSkip(LightProbeSHCoefficientsDefinition.ScalarSubParamOffset);
    UIntMetadata NumLightProbesParameter;
    UIntMetadata NumDivParameter;
	if (Header.Type ==4)
	{
		UIntMetadata FormatTypeParameter;
	}
} Metadata;

FSeek(Metadata.LightProbeSHCoefficientsDefinition.SelfStartPos);
FSkip(Metadata.LightProbeSHCoefficientsDefinition.DataOffset);
struct
{
    uint Times[Metadata.NumDivParameter.Value];

    AlignRead(16);

    struct
    {
        int NameStringOffset;
        int DataOffset;
    
        // Might be related to number of SH sets? An enum? 0 = 1 set, 3 = 28 sets, 4 = 3 sets, 7 = 30 sets. But not true in mgo?
        uint Unknown;
    } ProbeMetadata[Metadata.NumLightProbesParameter.Value];

    local int i = 0;
    for (i = 0; i < Metadata.NumLightProbesParameter.Value; i++)
    {
        FSeek(ProbeMetadata[i].DataOffset);

        struct LightProbe
        {
            local uint readBound; // Hack
            if (i == (Metadata.NumLightProbesParameter.Value - 1))
                readBound = FileSize() - 0x8;
            else
                readBound = Metadata.lightProbeMetadata[i + 1].DataOffset;
    
            while (FTell() < readBound && FTell() < FileSize())
            {
                ShCoefficientSet Coefficients;
            }
        } Probes <optimize=false>;
    }
} LightProbeSHCoefficients <bgcolor=0x00aaff>;

string HashLookup( StrCode32& hash )
{
 if( hash.hash == 981817376 )
     return "LightProbeSHCoefficients";
 else if( hash.hash == 3466735186 )
     return "numLightProbes";
 else if( hash.hash == 3667462730 )
     return "numDiv";
 else if( hash.hash == 3457030085 )
     return "formatType";
 else if( hash.hash == 2310196218 )
     return "LP_auto_0000";
 else
     return "";
}
#ifndef GR_COMMON_BT
#define GR_COMMON_BT

#include "../common/common.bt"

enum <uint> GR_FILE_TYPE
{
	GR_FILE_TYPE_ATSH = 1,
	GR_FILE_TYPE_OBRB = 2,
	GR_FILE_TYPE_HTRE_OBR = 3,
	GR_FILE_TYPE_LPSH_TRE2_HTRE = 4,
};

enum <ushort> ENTRY_PARAM_TYPE
{
	GR_ENTRY_PARAM_TYPE_UINT = 0,
	ENTRY_PARAM_TYPE_FLOAT = 2,
};

typedef struct
{
	StrCode32 Hash;
    uint StringOffset;
} MetadataString <read = ReadMetadataString>;
string ReadMetadataString(MetadataString& str)
{
	if (str.StringOffset == 0 || str.Hash.hash == 3205930904) // Empty string hash
		return "null";
	else if (str.Hash.hash == 2283831924 || str.Hash.hash == 4127755893 || str.Hash.hash == 981817376) // Hack for ObjectBrush (.obr, not .obrb), AtmosphereSHCoefficients (.atsh), and LightProbeSHCoefficients (.lpsh) which use an absolute string offset for this particular string for some reason
		return ReadString(str.StringOffset);
	else
		return ReadString(startof(str) + str.StringOffset);
}

typedef struct
{
    ENTRY_PARAM_TYPE Type;
    short NextParamOffset; //sizeof(GrMetadataEntryParameter)
	MetadataString Name;
	switch (Type)
	{
	case GR_ENTRY_PARAM_TYPE_UINT:
		uint Value;
		break;
	case ENTRY_PARAM_TYPE_FLOAT:
    	float Value;
		break;
	default:
		Assert(false, "Unknown parameter type.");
		break;
	}
} GrMetadataEntryParameter <read = ReadGrMetadataEntryParameter>;
string ReadGrMetadataEntryParameter(GrMetadataEntryParameter& param)
{
	switch (param.Type)
	{
	case GR_ENTRY_PARAM_TYPE_UINT:
		return Str("%s %s = %d", "uint", ReadMetadataString(param.Name), param.Value);
	case ENTRY_PARAM_TYPE_FLOAT:
		return Str("%s %s = %f", "float", ReadMetadataString(param.Name), param.Value);
	default:
		return "null";
	}

	return result;
}

typedef struct
{
	MetadataString Name; // Hash is 0 in OBR Type==3 ObjectBrush entry
    uint Unknown; // Only nonzero in HTRE Type==4 files and OBR Type==3 files
    uint DataOffset; // 0 means no data
    uint DataSize; // 0 means no data
    uint EditParamOffset; //Assert(EditParamOffset == 0);             // Only nonzero for configrationIds entry in HTRE Type==3 files
    uint ConfigrationIdsOffset; //Assert(ConfigrationIdsOffset == 0); // exe searches for this entry, Only nonzero for editParam entry in HTRE Type==3 files
    int PreviousEntryOffset; // 0 means no previous entries
    int NextEntryOffset; // 0 means no more entries
    uint EntryParametersOffset; // 0 means no params
    uint Padding0<hidden = true>; Assert(Padding0 == 0);
    uint Padding1<hidden = true>; Assert(Padding1 == 0);

	if (EntryParametersOffset != 0)
	{
		FSeek(startof(this) + EntryParametersOffset);
		local uint paramStartPos = FTell();

		GrMetadataEntryParameter Param;
		while (Param.NextParamOffset != 0)
		{
			paramStartPos += Param.NextParamOffset;
			FSeek(paramStartPos);

			GrMetadataEntryParameter Param;
		}
	}
} GrMetadataEntry <read = ReadMetadataString(Name)>;

int GetGrMetadataEntryParamIndex(GrMetadataEntry& entry, string name)
{
	local uint pIdx;
	for (pIdx = 0; exists(entry.Param[pIdx]); pIdx++)
	{
		if (Strcmp(ReadMetadataString(entry.Param[pIdx].Name), name) == 0)
			return pIdx;
	}

    return -1;
}

typedef struct 
{
	local uint entryStartPos = FTell();
	GrMetadataEntry Entry;
	while (Entry.NextEntryOffset != 0)
	{
		entryStartPos += Entry.NextEntryOffset;
		FSeek(entryStartPos);
		
		GrMetadataEntry Entry;
	}
} GrMetadataEntries <bgcolor = 0x7E846B>;

int GetGrMetadataEntryIndex(GrMetadataEntries& entries, string name)
{
	local uint eIdx;
	for (eIdx = 0; exists(entries.Entry[eIdx]); eIdx++)
	{
		if (Strcmp(ReadMetadataString(entries.Entry[eIdx].Name), name) == 0)
			return eIdx;
	}

    return -1;
}

typedef struct
{
	if (ReadUShort() == 0)
		BigEndian();
	else
		LittleEndian();

    GR_FILE_TYPE Type;
    uint MetadataEntriesOffset;
    uint FileSize;
	MetadataString Name;
} GrHeader <read = Str("%s, %s", EnumToString(Type), ReadMetadataString(Name)), bgcolor = 0xaaaaaa>;

#endif
// FRL - FoxRailData
// By RLC - inspired by other FOX templates by the researchers of Modders' Heaven!
// Based on notes from Ventos!
LittleEndian();

typedef struct
{
	float x;
	float y;
	float z;
} Float3 <read=Str("(%g, %g, %g)", x, y, z)>;

typedef struct
{
	float x;
	float y;
	float z;
	float w;
} Float4 <read=Str("(%g, %g, %g, %g)", x, y, z, w)>;

struct Header
{
	char signature[4] <hidden=true>;
	ushort version <hidden=true>;
	if (version!=2)
	{
		BigEndian();
	}
	ushort railsCount;
	
} header <bgcolor=0x8694EB>;

if ( FileSize() == ( FTell() + ( header.railsCount * 4 ) ) )
{
	struct RailIds
	{
		uint railHash;

	} railIds[header.railsCount] <bgcolor=0xB9E7CA, optimize=true>;
}
else
{
	FSkip(8);
	
	local uint railIndex = 0;
	
    // Uses a Cubic Hermite Spline
	struct Rail
	{
		FSeek( 0x10 + 0x30 * railIndex );
		
		Float3 startPoint; FSkip(4);
		Float3 endPoint; FSkip(4);
		uint offsetToStartOfRailNodes;
		uint offsetToSec2;
		uint offsetToSec3;
		ushort nodeCount;
		ushort sect23UnkCount;
		
		FSeek(offsetToStartOfRailNodes);
		local uint nodeIndex = 0;

        // HermiteCurve 
		struct Curve
		{
			Float3 position; float arcLength; // Length of Hermite
			Float3 tangent; float tangentLength; // tangentLength == length(tangent) == sqrt(tangent.x^2 + tangent.y^2 + tangent.z^2)
			nodeIndex++;
		} splineSegments[nodeCount] <bgcolor=0x8ADEF3, optimize=false>; 
		
		FSeek(offsetToSec2);
		struct Section2Entry
		{
			float unknownFloat1;
			ushort unknownShort1;
			ubyte byte0;
			ubyte byte1;
		} section2Entry[sect23UnkCount] <bgcolor=0xCAE7B9, optimize=true>;
		
		FSeek(offsetToSec3);
		struct Section3Entry
		{
			float unknown0;
		} section3Entry[sect23UnkCount/2] <bgcolor=0x97A7B3, optimize=true>;
		
		railIndex++;
		FSeek( 0x10 + 0x30 * railIndex );
	
	} rail[header.railsCount] <bgcolor=0x01062F, optimize=false>;
	
}
// FRL - FoxRailData
// By RLC - inspired by other FOX templates by the researchers of Modders' Heaven!
// Based on notes from Ventos!
LittleEndian();

struct Vector3
{
	float x;
	float y;
	float z;
};

struct Header
{
	char signature[4] <hidden=true>;
	ushort version <hidden=true>;
	if (version!=2)
	{
		BigEndian();
	}
	ushort railsCount;
	
} header <bgcolor=0x8694EB>;

if ( FileSize() == ( FTell() + ( header.railsCount * 4 ) ) )
{
	struct RailIds
	{
		uint railHash;

	} railIds[header.railsCount] <bgcolor=0xB9E7CA, optimize=true>;
}
else
{
	FSkip(8);
	
	local uint railIndex = 0;
	
	struct Rail
	{
		FSeek( 0x10 + 0x30 * railIndex );
		
		Vector3 startPoint; FSkip(4);
		Vector3 endPoint; FSkip(4);
		uint offsetToStartOfRailNodes;
		uint offsetToSec2;
		uint offsetToSec3;
		ushort nodeCount;
		ushort sect23UnkCount;
		
		FSeek(offsetToStartOfRailNodes);
		local uint nodeIndex = 0;
		local float totalW01 = 0;
		local float maxW00 = 0;
		struct RailNode
		{
			Vector3 coordinates; float keyframePos; if (maxW00<keyframePos) {maxW00=keyframePos;} // Usually W is empty in first node
			Vector3 parameters; float unknown; totalW01+=unknown; // Usually entirely empty in first node and sometimes in the last node
			nodeIndex++;
			
		} railNode[nodeCount] <bgcolor=0x8ADEF3, optimize=false>; 
		
		FSeek(offsetToSec2);
		struct Section2Entry
		{
			float unknownFloat1;
			ushort unknownShort1;
			ubyte byte0;
			ubyte byte1;
			
		} section2Entry[sect23UnkCount] <bgcolor=0xCAE7B9, optimize=true>;
		
		FSeek(offsetToSec3);
		struct Section3Entry
		{
			float unknown0;
			
		} section3Entry[sect23UnkCount/2] <bgcolor=0x97A7B3, optimize=true>;
		
		railIndex++;
		FSeek( 0x10 + 0x30 * railIndex );
	
	} rail[header.railsCount] <bgcolor=0x01062F, optimize=false>;
	
}
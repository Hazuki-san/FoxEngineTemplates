LittleEndian();

#include "../common/common.bt"
#include "geo_common.bt"

#define COLOR_HEADER 0xDFEFAA
#define COLOR_ENTRY 0x7DE39E
#define COLOR_ENTRYBVHSECTION 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_ENTRYMATERIALSECTION 0xB9E8DD
#define COLOR_BOUNDINGBOXCHUNK 0xF7F205

typedef struct 
{
    uint hash<format=hex>;
} MtrCode32 <read=(hash)>;

typedef struct
{
	local long SelfStartPos = FTell();

	GeoCollisionShapeHeader Header(GEO_FILE_TYPE_GEOM_GEOMS_GSKL);

	switch (Header.Type)
	{
	case GEO_COLLISION_SHAPE_TYPE_BOUNDING_BOX:
		{
			SetBackColor(COLOR_BOUNDINGBOXCHUNK);
			{
				WideVector3 BoundingBoxRadii <bgcolor=0xDBC48F, comment="Width/2, Height/2, Depth/2">;
				WideVector3 BoundingBoxCenter <bgcolor=0xDBC48F>;
			}
			SetBackColor(cNone);
		}
		break;
	case GEO_COLLISION_SHAPE_TYPE_QUAD:
	{
		local uint i;
	    for (i = 0; i < Header.EntryCount; i++)
	    {
			struct
			{
				short Offset0;
				short Offset1;
				short Offset2;
				short Offset3;
				short Unknown0; // Seemingly always negative.
			} IndexSet <read=Str("%d, %d, %d, %d, %d", this.Offset0, this.Offset1, this.Offset2, this.Offset3, this.Unknown0)>;
	    }
		
		if ((Header.VertexDataOffset & 0xfffffff) != 0)
			{
				FSeek(SelfStartPos + Header.VertexDataOffset * 16);

				struct
				{
					uint VertexCount;
					uint VerticesIndexOffset;

					uint Unknown0Or1; Assert(Unknown0Or1 == 0 || Unknown0Or1 == 1);

					uint OriginIndex;

					int64 VertexDataOffset; // This gets patched at runtime to use a FMDL pointer.
					
					uint FmdlVertexDataOffset;

					uint Padding0 <hidden = true>; Assert(Padding0 == 0);
				} VertexDataHeader;

				// mgsvtpp.exe!141bd7e9c
				if ((Header.Flags & GEO_COLLISION_SHAPE_FLAGS_USE_FMDL_VERTEX_DATA) == 0)
				{
					WideVector3 VertexData[VertexDataHeader.VertexCount] <optimize = true>;

					// origin = VertexData[VertexDataHeader.OriginIndex]
					// A: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset0] + origin
					// B: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset1] + origin
					// C: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset2] + origin
					// D: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset3] + origin
				}
				else if (VertexDataHeader.VertexDataOffset == 0 && false /* FMDL vertex pointer is null*/)
				{
					// A: WideVector3(0, -10000, 0, 0)
					// B: WideVector3(0, -10000, 1, 0)
					// C: WideVector3(1, -10000, 1, 0)
					// D: WideVector3(1, -10000, 0, 0)
				}
				else
				{
					// VertexData points to the VertexDataHeader.FmdlVertexDataOffset-adjusted fmdl data.
					// A: VertexData[IndexSet.Offset0]
					// B: VertexData[IndexSet.Offset1]
					// C: VertexData[IndexSet.Offset2]
					// D: VertexData[IndexSet.Offset3]
				}
			}
		}
		break;
	default:
        Assert(false, "Unknown CollisonShape type detected!");
	}
} DataChunk <read=Str("%s, %d", EnumToString(this.Header.Type), this.Header.Flags)>;

struct EntryDataChunkDefinition
{
	local uint SelfStartPos = FTell();

	byte IsFinalEntry;

	byte DataChunkCount;
	ushort DataChunksTotalDataSize;
	
	ushort BoundingBoxOrSubverticesOffset0;
	ushort Padding0 <hidden = true>; Assert(Padding0 == 0);
	
	ushort BoundingBoxOrSubverticesOffset1;
	ushort Padding1 <hidden = true>; Assert(Padding1 == 0);
	
	uint VerticesOffset;
	uint FirstDataChunkOffset;
	uint NextSectionOffset;
	
	COLLISION_TAGS CollisionTags();
};

struct EntryDataSection
{
    local uint SelfStartPos;
    local uint i;
	local uint nextBBChunkPos;

    while(!ReadUByte())
	{
        SelfStartPos = FTell();

		EntryDataChunkDefinition Entry;

        FSeek(SelfStartPos + Entry.FirstDataChunkOffset);

		// I'm going to have to stare at this for longer to understand what the heck is going on here.
		struct
		{
			local uint64 ptrs[6];
			ptrs[0] = SelfStartPos + Entry.FirstDataChunkOffset;
			local uint j = 1;
			local uint j_minusOne;
			local int iteratorIndex = 0;
			local int iteratorIndex_minusOne;
			local uint64 ptr;

			do
			{
				ptr = ptrs[iteratorIndex];

				j_minusOne = j - 1;
				iteratorIndex_minusOne = iteratorIndex - 1;

				FSeek(ptr + 4);
				if (ReadUInt() != 0) // if (Data.Header.NextBBDataChunkOffset != 0)
				{
					ptrs[j - 1] = ptr + ReadUInt() * 16;

					j_minusOne = j;
					iteratorIndex_minusOne = iteratorIndex;
				}
			
				j = j_minusOne;
				iteratorIndex = iteratorIndex_minusOne;
				FSeek(ptr);
				if ((ReadUInt() & 0x200) == 0) // if (Data.Header.Info.Flags & GEO_COLLISION_SHAPE_FLAGS_NO_PAYLOAD == 0)
				{
					DataChunk Data;

					if (Data.Header.NextIndexDataChunkOffset != 0)
					{
						if (true)
						{
							j = j_minusOne + 1;
							iteratorIndex = iteratorIndex_minusOne + 1;
							ptrs[j_minusOne] = ptr + Data.Header.NextIndexDataChunkOffset * 16;
						}
					}
				}
			} while (j > 0);
		} DataChunks;

        FSeek(SelfStartPos + 32);
	};

	// Skip last "dummy" data chunk definition
    FSkip(32);
};

struct EntryMaterialsSection
{
	byte MagicByte <hidden=true>;
    Assert(MagicByte == 0);
	
	byte InfoTriplet[3] <comment="(Material Count+1, Material Count+1, 1).">;
    Assert(InfoTriplet[0] == InfoTriplet[1]);
    Assert(InfoTriplet[2] == 1);
	
    local uint i = 0;
    for (i = 0; i < (InfoTriplet[0] - 1); i++)
    {
		MtrCode32 MaterialNameHash;
		FSkip(8);
    }
};

enum GEOM_ENTRY_TYPE
{
	GEOM_ENTRY_TYPE_0 = 0,
	GEOM_ENTRY_TYPE_6 = 6,
};

struct EntryBVHSection
{
	local uint SelfStartPos = FTell();

	Vector3 EntryBoundingBoxCorner; // Mysterious. mgsvtpp.exe!141b95c89

	ushort GridTotalDataSize;
	ushort DataChunkDefinitionsCount;

	Vector3 EntryBoundingBoxExtents;

	uint NextSectionOffset;

	Vector3 Vector;
	
	uint BlockCountX;
	uint BlockCountY;
	uint BlockCountZ;
	
	COLLISION_TAGS CollisionTags();
	
	struct
	{
		short NodeOffsets[BlockCountX * BlockCountY * BlockCountZ] <hidden = true>;

		local uint i;
		local uint j;
		for (i = 0; i < BlockCountX * BlockCountY * BlockCountZ; i++)
		{
			if (NodeOffsets[i] != -1)
			{
				FSeek(SelfStartPos + NodeOffsets[i]);

				struct
				{
					ushort EntryCount <hidden = true>;
					for (j = 0; j < EntryCount; j++)
						ushort DataChunkDefinitionIndex;
				} Node;
			}
			else
			{
				struct
				{
				} Node;
			}
		}
	} Nodes;
};

struct EntrySecondaryHeaderSection
{
	local uint SelfStartPos = FTell();

	StrCode32 UnusedHash0;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);
	
	GEOM_ENTRY_TYPE Type;
	Assert((SecondaryHeaderSection.Type == GEOM_ENTRY_TYPE_0) || (SecondaryHeaderSection.Type == GEOM_ENTRY_TYPE_6), "Unknown Entry section detected!");
	
    uint NextSectionOffset;
	
	uint RemainingEntryDataSize;
	
	uint64 Padding1<hidden=true>; //Assert(Padding1 == 0);
	uint Padding2<hidden=true>; Assert(Padding2 == 0);

	uint UnusedOffset<hidden=true>; Assert(UnusedOffset == 0);
};

struct EntryHeaderSection
{
	local uint SelfStartPos = FTell();

    StrCode32 UnusedHash0;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);

	uint UnknownFlag0x10Or0x40Or0xB; Assert(UnknownFlag0x10Or0x40Or0xB == 0x10 || UnknownFlag0x10Or0x40Or0xB == 0x40 || UnknownFlag0x10Or0x40Or0xB == 0xB); // mgsvtpp.exe!141bef7fa

	uint64 Padding1<hidden=true>; //Assert(Padding1 == 0);
	uint Padding2<hidden=true>; Assert(Padding2 == 0);
	
	uint NextSectionOffset; // Size of the header + padding
	
	int PreviousEntryOffset; // The value stored is positive, but it's for jumping backwards in list.
	
	uint NextEntryOffset; // Size of the entry + padding
}; // mgsvtpp.exe!14cd19a40

struct
{
	uint Version;
	uint FirstEntryOffset;
	uint FileSize;

	uint u1 <hidden=true>; Assert(u1 == 7050094);

	uint64 Padding0<hidden=true>; Assert(Padding0 == 0);

	StrCode32 UnusedHash0;
	StrCode32 UnusedHash1;
} Header <bgcolor=COLOR_HEADER>; // mgsvtpp!141bef7b2

local uint DefinitionStartPos = Header.FirstEntryOffset;
do
{
	FSeek(DefinitionStartPos);

	struct
	{
		local uint SelfStartPos = FTell();
		
		EntryHeaderSection HeaderSection;
		
		FSeek(HeaderSection.SelfStartPos + HeaderSection.NextSectionOffset);

		EntrySecondaryHeaderSection SecondaryHeaderSection;

		if (SecondaryHeaderSection.NextSectionOffset == 0)
			break;
		FSeek(SecondaryHeaderSection.SelfStartPos + SecondaryHeaderSection.NextSectionOffset);
		
		if (SecondaryHeaderSection.Type == GEOM_ENTRY_TYPE_0)
		{
			EntryBVHSection BVHSection<bgcolor=COLOR_ENTRYBVHSECTION>;
		
			FSeek(BVHSection.SelfStartPos + BVHSection.NextSectionOffset);
		}
		
		EntryDataSection EntryData<bgcolor=COLOR_CHUNK11>;
		
		EntryMaterialsSection Materials<bgcolor=COLOR_ENTRYMATERIALSECTION>;
	} CollisionDefinition <bgcolor=COLOR_ENTRY>;

	DefinitionStartPos += CollisionDefinition.HeaderSection.NextEntryOffset;
} while (CollisionDefinition.HeaderSection.NextEntryOffset != 0);
LittleEndian();

#include "../common/types.bt"
#include "geo_common.bt"

#define COLOR_HEADER 0xDFEFAA
#define COLOR_SECONDARYHEADER 0x7DE39E
#define COLOR_BVH 0xAED2E8
#define COLOR_EDGE 0xB9E8DD
#define COLOR_NODE 0x8ADEF3
#define COLOR_DATACHUNK 0x00AAFF
#define COLOR_DATACHUNKS 0xF7F205

local byte IsGPFP;

struct
{
    local uint SelfStartPos = FTell();

    uint Version;
    
    uint NextEntryOffset;

    uint FileSize;

    uint Identifier;
    if (Identifier == 3205930904)
        IsGPFP = true;
    else
        IsGPFP = false;

    uint64 Padding0 <hidden = true>; Assert(Padding0 == 0);
    uint64 Padding1 <hidden = true>; Assert(Padding1 == 0);
} Header <bgcolor = COLOR_HEADER>;

FSeek(Header.SelfStartPos + Header.NextEntryOffset);

struct
{
    local uint SelfStartPos = FTell();

    uint64 Padding0 <hidden = true>; Assert(Padding0 == 0);

    uint UnknownAlways12; Assert(UnknownAlways12 == 12);
    
    uint NextEntryOffset;

    uint FileSizePlus16; Assert(FileSizePlus16 == (Header.FileSize + 16));

    uint64 Padding1 <hidden = true>; Assert(Padding1 == 0);
    uint64 Padding2 <hidden = true>; Assert(Padding2 == 0);
    uint64 Padding3 <hidden = true>; Assert(Padding3 == 0);
    uint Padding4 <hidden = true>; Assert(Padding4 == 0);
} SecondaryHeader <bgcolor = COLOR_SECONDARYHEADER>;

FSeek(SecondaryHeader.SelfStartPos + SecondaryHeader.NextEntryOffset);

struct
{
    local uint SelfStartPos = FTell();
    
    WideVector3 BoundingBoxCorner;
    WideVector3 BoundingBoxExtents;

    float GridResolution;

    uint BlockCountX;
	uint Unknown;
	uint BlockCountZ;

	uint GridTotalDataSize;
    
    uint GridDataOffset;

    uint RemainingEntryDataSize;

    uint DataChunksOffset;

    FSeek(SelfStartPos + GridDataOffset);

	struct
	{
		short NodeOffsets[BlockCountX * BlockCountZ] <hidden = true>;

		local uint i;
		local uint j;
		for (i = 0; i < BlockCountX * BlockCountZ; i++)
		{
			if (NodeOffsets[i] != -1)
			{
				FSeek(SelfStartPos + NodeOffsets[i]);

				struct
				{
					uint EntryCount <hidden = true>;
					for (j = 0; j < EntryCount; j++)
						uint DataChunkDefinitionIndex;
				} Node;
			}
			else
			{
				struct
				{
				} Node;
			}
		}
	} Nodes;
} BVH <bgcolor = COLOR_BVH>;

FSeek(BVH.SelfStartPos + BVH.DataChunksOffset);

typedef struct
{
    local uint SelfStartPos = FTell();

    if (IsGPFP)
    {
		ReadGeoCollisionShapeHeader(GEO_FILE_TYPE_GPFP);

        struct Edge
        {
            uint Flags <format = binary>;
            ushort InIndex;
            ushort OutIndex;
        } Edges [Header.EntryCount] <bgcolor=COLOR_EDGE>;
        
        FSeek(SelfStartPos + Header.VertexDataOffset);

        local uint highestNodeIndex = 0;
        local uint i;
        if (Header.EntryCount > 0)
        {
            // Manually get number of vertices
            for (i = 0; i < Header.EntryCount; i++)
            {
                if (Edges[i].InIndex > highestNodeIndex)
                    highestNodeIndex = Edges[i].InIndex;
                else if (Edges[i].OutIndex > highestNodeIndex)
                    highestNodeIndex = Edges[i].OutIndex;
            }
        
            struct Node
            {
                Vector3 Position;
                uint Flags <format = binary>;
            } Nodes [highestNodeIndex + 1] <bgcolor=COLOR_NODE>;
        }
    }
    else
    {
        uint SelfIndex;
        uint VertexDataCount;
        uint Unknown0;
        float UnknownFloat0;

        Vector4 UnknownVector40;

        float UnknownFloat1;
        uint Unknown1;
        float UnknownFloat2;
        uint Padding1 <hidden = true>; Assert(Padding1 == 0);

        Vector4 UnknownVector40;

        Vector4 VertexData[VertexDataCount] <bgcolor=COLOR_NODE>;

        struct
        {
            float UnknownFloat0;
            short UnknownShorts[6];
        } UnknownData[4];
    }
} DataChunk <bgcolor = COLOR_DATACHUNK>;

struct
{
    local uint i;
    uint EntryCount <hidden = true>;

    uint FirstDataChunkSize <hidden = true>;

    uint Offsets[EntryCount] <hidden = true>;

    for (i = 0; i < EntryCount; i++)
    {
        FSeek(BVH.SelfStartPos + Offsets[i]);
        
        DataChunk DataChunkEntry;
    }

} DataChunks <bgcolor = COLOR_DATACHUNKS>;
LittleEndian();

#include "../common/types.bt"
#include "geo_common.bt"

#define COLOR_HEADER 0x9EADC8
#define COLOR_SECONDARYHEADER 0xDFEFAA
#define COLOR_EDGE 0xB9E8DD
#define COLOR_ENTITYASSOCIATIONS 0xAED2E8
#define COLOR_NODE 0x8ADEF3
#define COLOR_DATACHUNK 0x00AAFF
#define COLOR_DATACHUNKS 0xF7F205

struct
{
	uint Version;
	switch (Version)
	{
	case 0x00030000:
		break;
	case 0x00000300:
		BigEndian();
		break;
	default:
		Assert(false, "Invalid version.");
	}

	uint SomethingOffset;

	uint FileSize;

	FSkip(20);
} Header <bgcolor = COLOR_HEADER>;

FSeek(Header.SomethingOffset);

struct
{
    local uint SelfStartPos = FTell();

	uint DataOffset;

	uint NextEntryOffset;

	uint EntityAssociationCount;

	uint HashesOffset; // Linkage not immediately clear. For example,
	                   // afgh_bridge_fpkl_edit_tmp_large_win.geobv has three hashes:
					   // /Assets/tpp/level/location/afgh/block_large/bridge/afgh_bridge_light.fox2, 
					   // /Assets/tpp/level/location/afgh/block_large/bridge/afgh_bridge_gimmick.fox2, 
					   // /Assets/tpp/level/location/afgh/block_large/bridge/afgh_bridge_asset.fox2

	FSkip(8);

	uint EntityAssociationsOffset;

	uint UnallocatedEntityAssociationsOffset;
} SecondaryHeader <bgcolor = COLOR_SECONDARYHEADER>;


typedef struct
{
    local uint SelfStartPos = FTell();

	Vector3 UnknownV0;

	uint Unknown0;

	Vector3 UnknownV1;

	uint Unknown1;

	Vector3 UnknownV2;
	
	uint Unknown2;

	Vector3 UnknownV3;
	
	uint Unknown3;

	float GridSizeX;
	float GridSizeZ;

	uint GridCountX;
	uint GridCountZ;

	ushort Unknown4[8];

	WideVector3 UnknownV4;

	ushort Cells[GridCountX * GridCountZ] <bgcolor = COLOR_DATACHUNKS>;
} GridEntry <bgcolor = COLOR_NODE>;

FSeek(SecondaryHeader.SelfStartPos + SecondaryHeader.DataOffset);
GridEntry Entry0;

FSeek(SecondaryHeader.SelfStartPos + SecondaryHeader.NextEntryOffset);
GridEntry Entry1;

FSeek(SecondaryHeader.SelfStartPos + SecondaryHeader.EntityAssociationsOffset);

struct
{
	uint ArrayIndex;
	StrCode32 Hash; // References StaticModels and StaticModelArrays
} EntityAssocations[SecondaryHeader.EntityAssociationCount] <read = Str("%u", Hash.hash), bgcolor = COLOR_DATACHUNK>;

FSeek(SecondaryHeader.SelfStartPos + SecondaryHeader.HashesOffset);

struct
{
	uint Count;

	uint Padding0 <hidden = true>; Assert(Padding0 == 0);

	PathCode64 DataSetPaths[Count];
} Hashes <bgcolor = COLOR_EDGE>;

// local int i = 0;
// for (i = 0; i < EntryDefinitions.EntryCount; i++)
// {
//     FSeek(EntryDefinitions.SelfStartPos + EntryDefinitions.OffsetsOffset + EntryDefinitions.Offsets[i]);

//     struct
//     {
// 		GeoCollisionShapeHeader Header(GEO_FILE_TYPE_TRAP);
	    	
// 		switch (Header.Type)
// 		{
// 		case GEO_COLLISION_SHAPE_TYPE_BOX_TRAP:
// 			{
// 				struct BoxShape
// 				{
// 					Vector4 scale;	// I seem to remember Intrude triggers needing to be scaled up by two, but I don't remember if it applies to all boxes
					
// 					FSkip(16);
					
// 					Matrix4 Transform;
// 				} Shapes[Header.EntryCount] <optimize = true>;
// 			}
// 			break;
// 		case GEO_COLLISION_SHAPE_TYPE_PATH_TRAP:
// 			{
// 				struct PathShape
// 				{
// 					local uint SelfStartPos = FTell();
		
// 					float YMinimum;
// 					float YMaximum;
// 					uint PointCount <hidden = true>;
// 					uint PointsDataOffset <hidden = true>;
		
// 					FSeek(SelfStartPos + PointsDataOffset);
					
// 					WideVector3 Points[PointCount] <optimize = true>;
// 				} Shapes[Header.EntryCount] <optimize = false>;
// 			}
// 			break;
// 		default:
// 			Assert(false, "Unknown CollisonShape type detected!");
// 		}
//     } Entry <optimize = false, bgcolor = 0xD6D84F>;
// }
// FSM - FoxStreamMotion
// By RLC, based on documentation from BobDoleOwndU - inspired by other FOX templates by the researchers of Modders' Heaven!
// https://metalgearmodding.fandom.com/wiki/FSM

// Can be run on .fsm files and per-chunk output of FsmTool by BobDoleOwndU!
// https://github.com/BobDoleOwndU/FsmTool

//Joey's FoxDataNodes and etc:
#include "common/common.bt"
#include "common/anim_common.bt"

string ResolveHashFunc(StrCode32& hash)
{
	switch (hash.hash)
	{
	case 3933341002: return "ROOT";
	case 3254096966: return "DEMO";
	case 2620425302: return "CAMERA";
	case 3150281601: return "MOVE";
	case 2862912361: return "CameraParam";
	case 1885607306: return "SI Frame";
	case 1889896775: return "SKEL";
	case 2454300086: return "MESH_EVENT";
	case 143688520: return "MOTION";
	case 2215748180: return "MODEL";
	case 3736262940: return "SKELINFO";
	case 917055795: return "MTPINFO";
	case 2846912397: return "MTEV";
	case 494270195: return "MTP";
	case 2250865118: return "SHADER";
	case 3937479969: return "MTP_LIST";
	case 4042487769: return "MTP_PARENT_LIST";
	case 3187573380: return "LOCATOR";
	case 2036377104: return "GLOBALSRT";
	case 2053459263: return "Unknown";

	// Parameter names
	case 2570203771: return "TARGET_NAME";
	case 3426329078: return "SLOPE_DIR";
	case 35201703: return "SLOPE_ANGLE";

	default: return "";
	}
}

struct FoxDataString;
struct SAND
{
	switch (ResolveHashFunc(parentof(this).Name.Hash))
	{
	case "MOVE":
	case "CameraParam":
	case "SI Frame":
	case "SKEL":
	case "Unknown":
	case "MTP":
		AnimTracks Tracks;
		break;
	case "MTP_LIST":
	case "MTP_PARENT_LIST":
		struct ObjectMTPList
		{
			uint EntryCount <hidden = true>;
			local int64 mtpLstIdx;
			for (mtpLstIdx = 0; mtpLstIdx < EntryCount; mtpLstIdx++)
			{
				FoxDataString Entry <optimize = true>;
			}
		} List <bgcolor = 0xF38ADE>;
		break;
	case "MOTION":
		AnimTracks Tracks;
		break;
	default:
		{
			if (parentof(this).ParentNodeOffset != 0)
			{
				if (ReadUInt(startof(parentof(this)) + parentof(this).ParentNodeOffset) == 2250865118 /*SHADER*/)
				{
					AnimTracks Tracks;
				}
			}
		}
	}
};

#define FOX_DATA_FLAG_IS_HAS_PAYLOAD
#define FOX_DATA_RESOLVE_HASH_FUNC ResolveHashFunc

#define FOX_DATA_PAYLOAD SAND

#include "common/FoxData_common.bt"

local int passedSoundChunk = 0; // Probably a better way to tell that it's the first SND chunk

local int startOfChunk = FTell(); // In case is run from offset inside .fsm

struct DemoData
{
	uint chunkType;
	if (demoData.chunkType==0)
	{
		int u0;
		int startFrame; //chunk i is i*frameCount
		int frameCount;
					
		int segmentCount;
	}
				
	int offsetToChunkEnd <comment="Chunk size starting from demoData">;
	int offsetToEventSection <comment="Offset starts from demoData">;
				
	if (demoData.chunkType==1)
	{
		FSkip(0x4);
	}

};

while (FTell()!=FileSize())
{
	struct DemoChunk
	{
		startOfChunk = FTell(); // When the chunk needs to get the offset of its start
		
		struct Header
		{
			char sign[4]; if (sign=="OMED" || sign==" SYS" || sign==" DNS" || sign==" DNE") { BigEndian();BitfieldRightToLeft(); };
			uint chunkSize;
			double demoStart;
			
		} header <bgcolor=0x800000>;
		
		if (header.sign=="SYS " || header.sign==" SYS")
		{
			
		}
		else if (header.sign=="DEMO" || header.sign=="OMED")
		{
			DemoData demoData <bgcolor=0x800080>;

			if (demoData.chunkType==0)
			{
				struct MotionSection
				{
					struct SegmentOffsets
					{
						int segmentOffset[demoData.segmentCount];
						
					} segmentOffsetSection <bgcolor=0x008000, comment="Offsets start from demoData">;
					
					if (demoData.u0!=10)
					{
						struct RootVector3
						{
							float x;
							float y;
							float z;
							
						} rootVector3 <bgcolor=0xC08000, comment="World translation root of the demo chunk. Thanks to Ventos to pointing it out!">;
					};
					
					struct SegmentTypeIndices
					{
						ushort typeIndex[demoData.segmentCount];
						
					} indices <bgcolor=0x0080C0, comment="Might have something to do with what kinda data is in the Motions">;

					/*struct SegmentMotion
					{
						
						// There's some empty ones at the end with this kind of parsing, so maybe the type indices define the length of the individual segments
						if ((demoData.offsetToEventSection>0) & (demoData.offsetToEventSection<header.chunkSize))
						{
							while ( (FTell() - startOfChunk) < demoData.offsetToEventSection+0x10 )
							{
								ushort motion;
							}
						}
						else
						{
							while ( (FTell() - startOfChunk) < header.chunkSize )
							{
								ushort motion;
							}
						};
						
					} motion <optimize=false, bgcolor=0xC080C0, comment="Assuming .sand tells where animation data of what starts and ends.">;
					*/
					local uint segId=0;
					struct SegmentMotion
					{
						FSeek(startof(demoData)+segmentOffsetSection.segmentOffset[segId]);
						if (segId<demoData.segmentCount-1)
						{
							while (FTell()<startof(demoData)+segmentOffsetSection.segmentOffset[segId+1])
							{
								ushort motion;
							}
						}
						else
						{
							if ((demoData.offsetToEventSection>0) & (demoData.offsetToEventSection<header.chunkSize))
							{
								while ( (FTell() - startOfChunk) < demoData.offsetToEventSection+0x10 )
								{
									ushort motion;
								}
							}
							else
							{
								while ( (FTell() - startOfChunk) < header.chunkSize )
								{
									ushort motion;
								}
							};
						}
						segId++;
						
					} motion[demoData.segmentCount] <optimize=false, bgcolor=0xC080C0, comment="Assuming .sand tells where animation data of what starts and ends.">;

				} motionSection <optimize=false, bgcolor=0x008000>;
			};

			if (((demoData.chunkType==2) || (demoData.offsetToEventSection>0)) & (demoData.offsetToEventSection<header.chunkSize))
			{
				struct EventSection
				{
					struct EventOffsets
					{
						uint name <comment="StrCode32">;
						ushort eventCount;
						FSkip(0x2);
						uint offsetToEvent[eventCount]; // offset to a node from uint name here

					} eventOffsets <bgcolor=0x00C000, comment="Offsets to nodes, relative from the start of the section.">;

					if (demoData.chunkType==0)
					{
						if ((FTell() - startOfChunk) % 16 != 0)
						{
							FSkip(16 - ((FTell() - startOfChunk) % 16));
						}
					}
					else if (demoData.chunkType==2)
					{
						if ((FTell() - startOfChunk) % 16 != 0)
						{	
							FSkip(16 - ((FTell() - startOfChunk) % 16) - 4);
						}
						else
						{
							FSkip(0xC);
						};
					};
					
					// Thanks .evfs!
					// Something similar also seems to be used in .gani files.
					struct Event
					{
						StrCode32 Name;
						
						byte timeSectionCount; // Might be a bitfield, but unaffected by endianness
						byte paramIntCount;
						byte paramFloatCount;
						byte paramStringCount;
						
						if (timeSectionCount>0)
							struct TimeSection
							{
								int startFrame;
								int endFrame; // Two shorts? Endianness and all that really screws these up, especially some paramInts.
							} timeSection[timeSectionCount] <optimize=false>;
						
						if (paramIntCount>0)
							int paramInt[paramIntCount] <optimize=false>;
						
						if (paramFloatCount>0)
							float paramFloat[paramFloatCount] <optimize=false>;
							
						if (paramStringCount>0)
							uint64 paramString[paramStringCount] // Sometimes uses fox2/sand object name ie HM_mnt0_main0_def. lua messages too, or light functor events from fox2s
					} event[eventOffsets.eventCount] <optimize=false, bgcolor=0xF0F080>;
					
				} eventSection <bgcolor=0x00C000>;
			};

			if (FTell() % 16 != 0)
			{
				FSkip(16 - (FTell() % 16));
			}

			// GZ only. Since GZ has no .sand files, it uses this instead. Usually the first chunk, after SYS if that exists.
			if (demoData.chunkType==1)
			{
				FoxDataNodes Nodes <bgcolor=0x0CC0C0>;
			}
			
		}
		else if (header.sign=="SND " || header.sign==" DNS")
		{
			if (passedSoundChunk==0)
			{
				passedSoundChunk = 1; // There's probably a better way to tell that it's the first SND chunk to parse this section.
				struct SoundData
				{
					uint completeSoundFileLength;
					uint unknown0;
					ubyte u0;
					if (FTell() % 16 != 0)
					{
						FSkip(16 - (FTell() % 16));
					}
					
				} soundData <bgcolor=0xC04040>;
			}
			
			struct RiffSection
			{
				// I mean, do I reverse .wem files here or what?
				char riffData[(startOfChunk+header.chunkSize)-FTell()];
				
			} riffSection <bgcolor=0xF08040>;
			
		}
		else if (header.sign=="END " || header.sign==" DNE")
		{
			FSkip(FileSize()-FTell()); // Sometimes there's tons of null lines after the END
		}
		else
		{
			Assert(2+2==5, "Unknown Chunk Type!!!"); // In case something goes very very wrong
		}

		if (header.sign!="END " && header.sign!=" DNE")
			FSeek(startof(header.sign)+header.chunkSize);
		
	} demoChunk;
}
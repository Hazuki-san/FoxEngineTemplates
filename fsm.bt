// FSM - FoxStreamMotion
// By RLC, based on documentation from BobDoleOwndU - inspired by other FOX templates by the researchers of Modders' Heaven!
// https://metalgearmodding.fandom.com/wiki/FSM

// Can be run on .fsm files and per-chunk output of FsmTool by BobDoleOwndU!
// https://github.com/BobDoleOwndU/FsmTool

LittleEndian();
//Joey's FoxDataNodes and etc:
#include "common/common.bt"
#include "anim/anim_common.bt"

typedef enum <uint>
{
	ROOT            = 3933341002,
	DEMO            = 3254096966,
	CAMERA          = 2620425302,
	MOVE            = 3150281601,
	CameraParam     = 2862912361,
	SI_Frame        = 1885607306, // Technically, the hash is "SI Frame" with a space instead of an underscore. 
	SKEL	        = 1889896775,
	MESH_EVENT      = 2454300086,
	MOTION	        = 143688520,
	MODEL           = 2215748180,
	SKELINFO        = 3736262940,
	MTPINFO         = 917055795,
	MTEV            = 2846912397,
	MTP             = 494270195,
	SHADER          = 2250865118,
	MTP_LIST        = 3937479969,
	MTP_PARENT_LIST = 4042487769,
	LOCATOR         = 3187573380,
	GLOBALSRT       = 2036377104,
	Unknown         = 2053459263,

	// Parameter names
	TARGET_NAME     = 2570203771,
	SLOPE_DIR       = 3426329078,
	SLOPE_ANGLE     = 35201703,
} NodeNameHash <read = (EnumToString(this) == "" ? (uint)this : EnumToString(this))>;

struct FoxDataString;
struct SandPayload
{
	switch (parentof(this).Name.Hash)
	{
	case MOVE:
	case CameraParam:
	case SI_Frame:
	case SKEL:
	case Unknown:
	case MTP:
		AnimTracks Tracks;
		break;
	case MTP_LIST:
	case MTP_PARENT_LIST:
		struct ObjectMTPList
		{
			uint EntryCount <hidden = true>;
			local int64 mtpLstIdx;
			for (mtpLstIdx = 0; mtpLstIdx < EntryCount; mtpLstIdx++)
			{
				FoxDataString Entry <optimize = true>;
			}
		} List <bgcolor = 0xF38ADE>;
		break;
    case MOTION:
        AnimTracks Tracks;
        break;
	default:
		{
			if (parentof(this).ParentNodeOffset != 0)
			{
				if (ReadUInt(startof(parentof(this)) + parentof(this).ParentNodeOffset) == SHADER)
				{
					AnimTracks Tracks;
				}
			}
		}
	}
};

#define FOX_DATA_FLAG_IS_HAS_PAYLOAD
#define FOX_DATA_HASH_ENUM
#define FOX_DATA_HASH_TYPE NodeNameHash

#define FOX_DATA_PAYLOAD SandPayload

#include "common/FoxDataCommon.bt"

local int passedSoundChunk = 0; // Probably a better way to tell that it's the first SND chunk

local int startOfChunk = FTell(); // In case is run from offset inside .fsm

struct DemoData
{
    uint chunkType;
    if (demoData.chunkType==0)
    {
        int u0;
        int startFrame; //chunk i is i*frameCount
        int frameCount;
					
        int segmentCount;
    }
				
    int offsetToChunkEnd <comment="Chunk size starting from demoData">;
    int offsetToEventSection <comment="Offset starts from demoData">;
				
    if (demoData.chunkType==1)
    {
        FSkip(0x4);
    }

};

while (FTell()!=FileSize())
{
	struct DemoChunk
	{
		startOfChunk = FTell(); // When the chunk needs to get the offset of its start
		
		struct Header
		{
			char sign[4]; if (sign=="OMED" || sign==" SYS" || sign==" DNS" || sign==" DNE") { BigEndian(); };
			uint chunkSize;
			double demoStart;
			
		} header <bgcolor=0x800000>;
		
		if (header.sign=="SYS " || header.sign==" SYS")
		{
			
		}
		else if (header.sign=="DEMO" || header.sign=="OMED")
		{
            DemoData demoData <bgcolor=0x800080>;

			if (demoData.chunkType==0)
			{
				struct MotionSection
				{
					struct SegmentOffsets
					{
						int segmentOffset[demoData.segmentCount];
						
					} segmentOffsetSection <bgcolor=0x008000, comment="Offsets start from demoData">;
					
					if (demoData.u0!=10)
					{
						struct RootVector3
						{
							float x;
							float y;
							float z;
							
						} rootVector3 <bgcolor=0xC08000, comment="World translation root of the demo chunk. Thanks to Ventos to pointing it out!">;
					};
					
					struct SegmentTypeIndices
					{
						ushort typeIndex[demoData.segmentCount];
						
					} indices <bgcolor=0x0080C0, comment="Might have something to do with what kinda data is in the Motions">;

					struct SegmentMotion
					{
						// There's some empty ones at the end with this kind of parsing, so maybe the type indices define the length of the individual segments
						if ((demoData.offsetToEventSection>0) & (demoData.offsetToEventSection<header.chunkSize))
						{
							while ( (FTell() - startOfChunk) < demoData.offsetToEventSection+0x10 )
							{
								ushort motion;
							}
						}
						else
						{
							while ( (FTell() - startOfChunk) < header.chunkSize )
							{
								ushort motion;
							}
						};
						
					} motion <optimize=false, bgcolor=0xC080C0, comment="Assuming .sand tells where animation data of what starts and ends.">;
					
				} motionSection <optimize=false, bgcolor=0x008000>;
			};

			if (((demoData.chunkType==2) || (demoData.offsetToEventSection>0)) & (demoData.offsetToEventSection<header.chunkSize))
			{
				struct EventSection
				{
					struct EventOffsets
					{
						uint name <comment="StrCode32">;
						ushort eventCount;
						FSkip(0x2);
						uint offsetToEvent[eventCount]; // offset to a node from uint name here

					} eventOffsets <bgcolor=0x00C000, comment="Offsets to nodes, relative from the start of the section.">;

					if (demoData.chunkType==0)
					{
						if ((FTell() - startOfChunk) % 16 != 0)
						{
							FSkip(16 - ((FTell() - startOfChunk) % 16));
						}
					}
					else if (demoData.chunkType==2)
					{
						if ((FTell() - startOfChunk) % 16 != 0)
						{	
							FSkip(16 - ((FTell() - startOfChunk) % 16) - 4);
						}
						else
						{
							FSkip(0xC);
						};
					};
					
					// Thanks .evfs!
					// Something similar also seems to be used in .gani files.
					struct Event
					{
						uint eventType <comment="Node type hash - usually ExecCommand/595181585">;
						
						byte timeSectionCount; // Might be a bitfield, but unaffected by endianness
						byte paramIntCount;
						byte paramFloatCount;
						byte paramStringCount;
						
                        if (timeSectionCount>0)
						    struct TimeSection
						    {
							    int startFrame;
							    int endFrame; // Two shorts? Endianness and all that really screws these up, especially some paramInts.
							    
						    } timeSection[timeSectionCount] <optimize=false>;
						
                        if (paramIntCount>0)
					    	int paramInt[paramIntCount] <optimize=false>;
						
                        if (paramFloatCount>0)
						    float paramFloat[paramFloatCount] <optimize=false>;
							
                        if (paramStringCount>0)
						    uint64 paramString[paramStringCount] <comment="Sometimes uses fox2/sand object name ie HM_mnt0_main0_def. lua messages too, or light functor events from fox2s", optimize=false>;
						
					} event[eventOffsets.eventCount] <optimize=false, bgcolor=0xF0F080>;
					
				} eventSection <bgcolor=0x00C000>;
			};

			if (FTell() % 16 != 0)
			{
				FSkip(16 - (FTell() % 16));
			}

			// GZ only. Since GZ has no .sand files, it uses this instead. Usually the first chunk, after SYS if that exists.
			if (demoData.chunkType==1)
			{
                FoxDataNodes Nodes <bgcolor=0x0CC0C0>;
			}
			
		}
		else if (header.sign=="SND " || header.sign==" DNS")
		{
			if (passedSoundChunk==0)
			{
				passedSoundChunk = 1; // There's probably a better way to tell that it's the first SND chunk to parse this section.
				struct SoundData
				{
					uint completeSoundFileLength;
					uint unknown0;
					ubyte u0;
					if (FTell() % 16 != 0)
					{
						FSkip(16 - (FTell() % 16));
					}
					
				} soundData <bgcolor=0xC04040>;
			}
			
			struct RiffSection
			{
				// I mean, do I reverse .wem files here or what?
				char riffData[(startOfChunk+header.chunkSize)-FTell()];
				
			} riffSection <bgcolor=0xF08040>;
			
		}
		else if (header.sign=="END " || header.sign==" DNE")
		{
			FSkip(FileSize()-FTell()); // Sometimes there's tons of null lines after the END
		}
		else
		{
			Assert(2+2==5, "Unknown Chunk Type!!!"); // In case something goes very very wrong
		}

        if (header.sign!="END " && header.sign!=" DNE")
            FSeek(startof(header.sign)+header.chunkSize);
		
	} demoChunk;
}
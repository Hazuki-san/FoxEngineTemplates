LittleEndian();

void AlignRead(int alignment)
{
    local long alignmentRequired = FTell() % alignment;
    if (alignmentRequired > 0)
        FSeek(FTell() + alignment - alignmentRequired);
}

typedef struct
{
    uint hash<format=hex>;
} StrCode32 <read=(hash)>;

typedef struct
{
    hfloat x;
    hfloat y;
    hfloat z;
} Half3 <read=Str("(%f, %f, %f)", x, y, z)>;

struct ShCoefficients
{
    Half3 coefficients[10];
};

typedef struct
{
    ushort VariableType; // 0: uint, 2: float
    ushort NextMetadataOffset; //sizeof(FloatMetadata) or 0
    StrCode32 NameHash;
    uint NameStringOffset;
    float Value;
} FloatMetadata <read=Str("(%s, %f)", HashLookup(NameHash), Value)>;

typedef struct
{
    ushort VariableType; // 0: uint, 2: float
    ushort NextMetadataOffset; // sizeof(UIntMetadata) or 0
    StrCode32 NameHash;
    uint NameStringOffset;
    uint Value;
} UIntMetadata <read=Str("(%s, %d)", HashLookup(NameHash), Value)>;

typedef struct
{
    local uint SelfStartPos = FTell();

    StrCode32 NameHash <read=HashLookup(this)>; // 0 in OBR Type==3 ObjectBrush entry
    uint NameStringOffsetRelative;
    uint Unknown<hidden=true>; // Only nonzero in HTRE Type==4 files and OBR Type==3 files
    uint DataOffset; // 0 means no data
    uint DataSize; // 0 means no data
    uint EditParamOffset; Assert(EditParamOffset == 0);             // Only nonzero for configrationIds entry in HTRE Type==3 files
    uint ConfigrationIdsOffset; Assert(ConfigrationIdsOffset == 0); // exe searches for this entry, Only nonzero for editParam entry in HTRE Type==3 files
    int PreviousEntryOffset; // 0 means no previous entries
    int NextEntryOffset; // 0 means no more entries
    uint ScalarSubParamOffset; // 0 means no subparams
    uint padding2<hidden=true>; Assert(padding2 == 0);
    uint padding3<hidden=true>; Assert(padding3 == 0);
} SectionMetadata <read=Str("%s", HashLookup(NameHash))>;

struct
{
    uint Type;
    uint FirstSectionOffset; Assert(FirstSectionOffset == 0x20);
    uint FileSize;
    StrCode32 NameHash <read=HashLookup(this)>;
    uint NameStringOffset;
} Header<bgcolor=0xaaaaaa>;

FSeek(Header.FirstSectionOffset);

struct
{
    SectionMetadata AtmosphereSHCoefficientsDefinition<bgcolor=0xff9999>;
    FSeek(AtmosphereSHCoefficientsDefinition.SelfStartPos);
    FSkip(AtmosphereSHCoefficientsDefinition.ScalarSubParamOffset);
    UIntMetadata NumDivParameter<bgcolor=0xff9900>;
    UIntMetadata NumWeathersParameter<bgcolor=0x00ff99>;
} Metadata;

FSeek(Metadata.AtmosphereSHCoefficientsDefinition.SelfStartPos);
FSkip(Metadata.AtmosphereSHCoefficientsDefinition.DataOffset);

struct
{
    uint Times[Metadata.NumDivParameter.Value];

    AlignRead(16);

    local int i = 0;
    for (i = 0; i < Metadata.NumWeathersParameter.Value; i++)
    {
        struct
        {
            ShCoefficients Coefficients [Metadata.NumDivParameter.Value];
        } ShSet;
    }
} AtmosphereSHCoefficients <bgcolor=0x00aaff>;;

string HashLookup( StrCode32& hash )
{
 if( hash.hash == 4127755893 )
     return "AtmosphereSHCoefficients";
 else if( hash.hash == 3667462730 )
     return "numDiv";
 else if( hash.hash == 75172507 )
     return "numWeathers";
 else
     return "";
}
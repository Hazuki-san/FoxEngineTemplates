LittleEndian();

#include "common/common.bt"
#include "anim/anim_common.bt"

typedef enum <uint>
{
	ROOT            = 3933341002,
	DEMO            = 3254096966,
	CAMERA          = 2620425302,
	MOVE            = 3150281601,
	CameraParam     = 2862912361,
	SI_Frame        = 1885607306, // Technically, the hash is "SI Frame" with a space instead of an underscore. 
	SKEL	        = 1889896775,
	MESH_EVENT      = 2454300086,
	MOTION	        = 143688520,
	MODEL           = 2215748180,
	SKELINFO        = 3736262940,
	MTPINFO         = 917055795,
	MTEV            = 2846912397,
	MTP             = 494270195,
	SHADER          = 2250865118,
	MTP_LIST        = 3937479969,
	MTP_PARENT_LIST = 4042487769,
	LOCATOR         = 3187573380,
	GLOBALSRT       = 2036377104,
	Unknown         = 2053459263,

	// Parameter names
	TARGET_NAME     = 2570203771,
	SLOPE_DIR       = 3426329078,
	SLOPE_ANGLE     = 35201703,
} NodeNameHash <read = (EnumToString(this) == "" ? (uint)this : EnumToString(this))>;

struct Header
{
	uint Version; // June 23rd, 2014 if (magic==372703500) { BigEndian();}
	uint FileSize; Assert(FileSize == FileSize());
	uint sectionParamCount; Assert(sectionParamCount==4); // Four sections always
	uint objectCount;
		
	struct SectionParams
	{
		uint sectionId;
		uint sectionEntriesCount; // Always same as objectCount, amount of Section 2 entry offsets
		uint sectionStartOffset; // Offset to section start, from the start of the line
		uint sectionSize;
	} sectionParams[sectionParamCount] <fgcolor=0x8694EB>; // ROOT Section Params
	
} header <bgcolor=0xB3A797>;

FSeek(startof(header.sectionParams[0]) + header.sectionParams[0].sectionStartOffset);

struct
{
	local int64 trkIdx;
	for (trkIdx = 0; trkIdx < header.sectionParams[0].sectionEntriesCount; trkIdx++)
		uint TracksOffset <optimize = true>; // Global offsets to nodes' tracks
} TracksOffsets <bgcolor=0x8694EB>;

FSeek(startof(header.sectionParams[1]) + header.sectionParams[1].sectionStartOffset);

struct SandPayload
{
	switch (parentof(this).Name.Hash)
	{
	case MOVE:
	case CameraParam:
	case SI_Frame:
	case SKEL:
	case Unknown:
	case MTP:
		AnimTracks Tracks;
		break;
	case MTP_LIST:
	case MTP_PARENT_LIST:
		struct ObjectMTPList
		{
			uint EntryCount <hidden = true>;
			local int64 mtpLstIdx;
			for (mtpLstIdx = 0; mtpLstIdx < EntryCount; mtpLstIdx++)
			{
				struct MTPEntry
				{
					StrCode32 name;
					uint Padding; Assert(Padding == 0);
				} Entry <read = (name.hash), optimize = true>;
			}
		} List <bgcolor = 0xF38ADE>;
		break;
	default:
		{
			if (parentof(this).ParentNodeOffset != 0)
			{
				if (ReadUInt(startof(parentof(this)) + parentof(this).ParentNodeOffset) == SHADER)
				{
					AnimTracks Tracks;
				}
			}
		}
	}
};

#define FOX_DATA_FLAG_IS_HAS_PAYLOAD
#define FOX_DATA_HASH_ENUM
#define FOX_DATA_HASH_TYPE NodeNameHash

#define FOX_DATA_PAYLOAD SandPayload

#include "common/FoxDataCommon.bt"

FoxDataNodes Nodes;

FSeek(startof(header.sectionParams[2]) + header.sectionParams[2].sectionStartOffset);

struct
{
	local int64 cmIdx;
	for (cmIdx = 0; cmIdx < header.sectionParams[2].sectionEntriesCount; cmIdx++)
	{
		struct CameraObject
		{
			StrCode32 Name; // Hash of the object name, sometimes CameraParam or SI Frame.
			uint Id;
		} Object <read = Str("Name: %u, Id: %u", Name.hash, Id), optimize = false>;
	}
} CameraObjects <bgcolor=0xB9E7CA>;

FSeek(startof(header.sectionParams[3]) + header.sectionParams[3].sectionStartOffset);

struct
{
	local int64 moIdx;
	for (moIdx = 0; moIdx < header.sectionParams[3].sectionEntriesCount; moIdx++)
	{
		struct MoveObject
		{
			StrCode32 Name; // Hash of the object name from fox2, ie HM_sna0_main0_def
			short aShort0;
			short aShort1; // These can be FFFF
			short aShort2;
			short aShort3;
			uint offset;
		} Object <read = Str("Name: %u", Name.hash), optimize = false>;
	}
} MoveObjects <bgcolor=0x9A7F7E>;
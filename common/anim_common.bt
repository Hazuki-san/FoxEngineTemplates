#ifndef ANIM_COMMON_BT
#define ANIM_COMMON_BT

typedef struct
{
	ushort value <hidden = true>;
} AnimHalf <read = ReadAnimHalf>;
string ReadAnimHalf(AnimHalf& animHalf)
{
	local uint sign = (animHalf.value & 0x8000) >> 8;
	local uint exponent = animHalf.value & 0x7C00;
	if (exponent > 0)
		exponent = exponent + 0x1DC00 >> 3;
	local uint mantissa = (animHalf.value & 1023) << 5;

	local ubyte value[4];
	value[0] = 0;
	value[1] = mantissa & 0xFF;
	value[2] = exponent & 0x80 | (mantissa >> 8) & 0xFF;
	value[3] = sign | exponent >> 8 & 0xFF;

	float result = ConvertBytesToFloat(value);

	return Str("%f", result);
}

enum <ubyte> TrackType
{
	TRACK_TYPE_QUAT = 0,
	TRACK_TYPE_FLOAT = 1,
	TRACK_TYPE_VECTOR2 = 2,
	TRACK_TYPE_VECTOR3 = 3,
	TRACK_TYPE_VECTOR4 = 4,
	TRACK_TYPE_QUAT_DIFF = 5,
	TRACK_TYPE_ROOT_POS = 6,
};

typedef struct
{
	AnimHalf x;
	AnimHalf y;
	AnimHalf z;
} VectorAnimH3 <read = Str("(%s, %s, %s)", ReadAnimHalf(x), ReadAnimHalf(y), ReadAnimHalf(z))>;

typedef struct
{
	AnimHalf x;
	AnimHalf y;
	AnimHalf z;
	AnimHalf w;
} VectorAnimH4 <read = Str("(%s, %s, %s, %s)", ReadAnimHalf(x), ReadAnimHalf(y), ReadAnimHalf(z), ReadAnimHalf(w))>;

// These are not padded! BitfieldDisablePadding() needs to be called before using them. 
// The frame count after each instance is also not padded!
typedef struct
{
	ushort X : 12;
	ushort Y : 12;
	ushort Z : 12;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim12;

typedef struct
{
	ushort X : 13;
	ushort Y : 13;
	ushort Z : 13;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim13;

typedef struct
{
	ushort X : 15;
	ushort Y : 15;
	ushort Z : 15;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim15;

struct AnimKeyframeData(TrackType type, ubyte componentBitSize)
{
	switch (type)
	{
		case TRACK_TYPE_QUAT:
			switch (componentBitSize)
			{
			case 12:
				QuatAnim12 Value;
				break;
			case 13:
				QuatAnim13 Value;
				break;
			case 15:
				QuatAnim15 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case TRACK_TYPE_FLOAT:
			switch (componentBitSize)
			{
			case 16:
				AnimHalf Value;
				break;
			case 32:
				float Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case TRACK_TYPE_VECTOR3:
			switch (componentBitSize)
			{
			case 0:
				break;
			case 16:
				VectorAnimH3 Value;
				break;
			case 32:
				Vector3 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case TRACK_TYPE_VECTOR4:
			switch (componentBitSize)
			{
			case 16:
				VectorAnimH4 Value;
				break;
			case 32:
				Vector4 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case TRACK_TYPE_QUAT_DIFF:
			switch (componentBitSize)
			{
			case 12:
				QuatAnim12 Value;
				break;
			case 15:
				QuatAnim15 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case TRACK_TYPE_ROOT_POS:
			switch (componentBitSize)
			{
			case 32:
				Vector3 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		default:
			Printf("@%Lx Unknown component bit size: %u\n", FTell(), componentBitSize);
			Assert(false);
			break;
	}
};

struct TrackDataBlob(TrackType type, ubyte componentBitSize, ubyte noFrames)
{
	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldDisablePadding();
	AnimKeyframeData InitFrame(type, componentBitSize);
	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldEnablePadding();

	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldDisablePadding();
	if (noFrames == 0)
	{
		local uint frameIndex = 0;
		do
		{
			struct AnimKeyframe(TrackType type, ubyte componentBitSize)
			{
				ubyte FrameCount : 8;

				AnimKeyframeData Data(type, componentBitSize);
			} Key(type, componentBitSize);

			frameIndex += Key.FrameCount;
		}
		while (frameIndex < FrameCount);
	}
	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldEnablePadding();

	FAlign(2);
};

typedef enum <ubyte>
{
	TRACK_UNIT_FLAGS_LOOP = 0x1,
	TRACK_UNIT_FLAGS_HERMITE_VECTOR_INTERPOLATION = 0x2,
	TRACK_UNIT_FLAGS_NO_FRAMES = 0x4,
} TrackUnitFlags <read = ReadTrackUnitFlags>;
string ReadTrackUnitFlags(TrackUnitFlags flags)
{
	local string result = flags == 0 ? "" : "| ";
	local ubyte i;
	local string enumName;
	local TrackUnitFlags temp;
	for (i = 1; i < 0x8; i = i << 1)
	{
		temp = flags & i;
		enumName = EnumToString(temp);
		if (enumName != "")
			result += " " + enumName + " |";
	}

	return result;
}

typedef struct
{
	uint ChannelCount;

	uint TrackCount;
	
	ushort HeaderIndex; // Used in SAND and set to 1 for TPP-style MTAR bind pose

	ubyte Unknown;

	ubyte Flag;

	uint FrameCount;

	uint Unknown1;

	uint UnitOffsets[ChannelCount] <hidden = true>;

	local uint trkIdx;
	for (trkIdx = 0; trkIdx < ChannelCount; trkIdx++)
	{
		FSeek(startof(this) + UnitOffsets[trkIdx]);

		struct TrackUnit
		{
			// For SAND, hash of the sub object, like a bone, ie SKL_000_WAIST. For GANI, it's the name of a Motion Point.
			enum <uint> TrackName_StrCode32Alias
			{
				// CANI, UIA, etc.
				ROTATE          = 283103795,
				SCALE           = 2236677358,
				TRANSLATE       = 2739596730,
				COLOR           = 1662570759,

				// 
			} Name;

			ubyte SegmentCount;

			TrackUnitFlags Flags;

			ushort Padding <hidden = true>; Assert(Padding == 0);

			struct TrackData
			{
				int DataOffset;

				short MotionSegmentId; // .fsm DEMO chunk motion segment id
				
				TrackType Type : 4;

				ubyte NextEntryOffset : 4; Assert(NextEntryOffset == 0 || NextEntryOffset == 8); // The offset to the next entry is (NextEntryOffset & 0x8). since NextEntryOffset is always 0 or 8, this does nothing. 

				ubyte ComponentBitSize;

#ifdef FILE_TYPE_MTAR2
				if (DataOffset != 0 && HeaderIndex < 1)
#else
				if (DataOffset != 0)
#endif
				{
					FSeek(startof(this) + DataOffset);

					TrackDataBlob Data(Type, ComponentBitSize, Flags & TRACK_UNIT_FLAGS_NO_FRAMES);

					FSeek(startof(this) + 8); // + sizeof(TrackData)
				}
			} SegmentHeaders[SegmentCount] <read = EnumToString(Type), optimize = false>;
		} Track;
	}
} TrackHeader <bgcolor = 0x8ADEF3>;

//Hack for PS3 files
typedef struct
{
    uint paramA <hidden=true>;
    uint paramB <hidden=true>;
	local StrCode param<format=hex>;
	param.hash = (ulong)paramA|(ulong)paramB*4294967296; //cbf with bitshifting, loops at 32
} PARAM_STRING <read=Str("%I64u",param.hash)>; 

typedef struct
{
	enum <uint> EvfCategoryName_StrCode32Alias
	{
		Normal = 3371498678,
		ag = 2079928349,
		cc = 3342815349,
		fx = 2569337208,
		sd = 179473302,
		vo = 1455888052,
	} CategoryName;

	ushort UnitCount <hidden = true>;

	ushort ExtraSectionOffset;

	if (UnitCount != 0)
		uint UnitOffsets[UnitCount] <hidden = true>;

	local uint sIdx;
	for (sIdx = 0; sIdx < UnitCount; sIdx++)
	{
		FSeek(startof(this) + UnitOffsets[sIdx]);
		
		struct EventUnitInfo
		{
			enum <uint> EventUnitInfoEventName_StrCode32Alias
			{
				// fx
				FX_CREATE_EFFECT_WITH_SKL = 312449893,

				// ag
				MTEV_AG_SYNC_L = 877721620,
				MTEV_AG_SYNC_R = 3647133869,
				MTEV_FOOT_STOP_R = 2051014260,
				MTEV_FOOT_STOP_L = 4246579437,
				MTEV_FOOT_START_R = 3689287927,
				MTEV_FOOT_START_L = 3049626829,

				// sd
				right_foot_ground = 2122718581,
				right_foot_leave = 3453979597,
				left_foot_ground = 1190238672,
				left_foot_leave = 3446064903,
				rattle_weapon = 2416440354,
				rattle_suit = 1532442511,
			} EventName;

			byte TimeSectionCount : 6 <hidden = true>;
			enum <byte> TIME_SECTION_FORMAT
			{
				TIME_SECTION_FORMAT_INT = 0,
				TIME_SECTION_FORMAT_SHORT = 1,
				TIME_SECTION_FORMAT_BYTE = 2,
				TIME_SECTION_FORMAT_INFINITE = 3,
			} Format : 2 <hidden = true>;

			byte IntParamCount <hidden = true>;
			byte FloatParamCount <hidden = true>;
			byte StringParamCount <hidden = true>;

			if (TimeSectionCount != 0)
			{
				struct TimeSection
				{
					switch (parentof(this).Format)
					{
					case TIME_SECTION_FORMAT_INT:
						int StartFrame <read = (this < 0 ? this : this & 0xBFFFFFFF)>;
						int EndFrame <read = (this < 0 ? this : this & 0xBFFFFFFF)>;
						break;
					case TIME_SECTION_FORMAT_SHORT:
						short StartFrame;
						short EndFrame;
						break;
					case TIME_SECTION_FORMAT_BYTE:
						byte StartFrame;
						byte EndFrame;
						break;
					case TIME_SECTION_FORMAT_INFINITE:
						break;
					}
					// This read function gets messy because of the formats but basically it's just saying TIME_SECTION_FORMAT_INFINITE -> (-1, 1), else to whatever the read function above is (which is only non-default for TYPE_INT).
				} TimeSections[TimeSectionCount] <read = (parentof(this).Format == TIME_SECTION_FORMAT_INFINITE ? "(-1, -1)" : Str("(%d, %d)", parentof(this).Format == TIME_SECTION_FORMAT_INT ? (StartFrame < 0 ? StartFrame : StartFrame & 0xBFFFFFFF) : StartFrame, parentof(this).Format == TIME_SECTION_FORMAT_INT ? (EndFrame < 0 ? EndFrame : EndFrame & 0xBFFFFFFF) : EndFrame)), optimize = true>;
			}

			FAlign(4);

			if (IntParamCount != 0)
				uint IntParams[IntParamCount];

			if (FloatParamCount != 0)
				float FloatParams[FloatParamCount];

			if (StringParamCount != 0)
				PARAM_STRING StringParams[StringParamCount];
		} Event <read = EnumToString(EventName)>;
	}

	if (ExtraSectionOffset != 0)
	{
		FSeek(startof(this) + ExtraSectionOffset);

		struct EventExtraInfo
		{
			uint IntParamOffset;
			uint IntParamCount;

			uint Unknown0; // Assert(Unknown0 == 0);
			uint Unknown1; //Assert(Unknown1 == 2);

			uint StringParamOffset;
			uint StringParamCount;

			if (IntParamOffset != 0) Assert(IntParamCount != 0 && FTell() == startof(IntParamOffset) + IntParamOffset);
			if (IntParamCount != 0)
				uint IntParams[IntParamCount];

			if (StringParamOffset != 0) Assert(StringParamCount != 0 /*&& FTell() == startof(StringParamOffset) + StringParamOffset*/);
			FSeek(startof(StringParamOffset) + StringParamOffset);
			if (StringParamCount != 0)
				StrCode StringParams[StringParamCount];
		} ExtraInfo;
	}
} EvpData <read = EnumToString(CategoryName), bgcolor = 0x00C010>;

typedef struct
{
	uint Version <hidden = true>;

	uint Count <hidden = true>;

	uint EntryOffsets[Count] <hidden = true>;

	local uint eIdx;
	for (eIdx = 0; eIdx < Count; eIdx++)
	{
		FSeek(startof(this) + EntryOffsets[eIdx]);

		EvpData Data;
	}
} EvpGroup <bgcolor = 0x00C000>;

#endif
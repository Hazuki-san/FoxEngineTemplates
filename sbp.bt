// SBP - SoundBank Package
// By RLC, based on: https://wiki.xentax.com/index.php/Wwise_SoundBank_(*.bnk) https://github.com/secaproject/SBP_tool

enum LipAnimIndex
{
	A	=	0,
	AH	=	1,
	AY	=	2,
	B	=	3,
	C	=	4,
	CH	=	5,
	D	=	6,
	E	=	7,
	EE	=	8,
	ER	=	9,
	F	=	10,
	G	=	11,
	H	=	12,
	I	=	13,
	J	=	14,
	L	=	15,
	M	=	16,
	N	=	17,
	NG	=	18,
	OH	=	19,
	OO	=	20,
	OU	=	21,
	OW	=	22,
	OY	=	23,
	P	=	24,
	R	=	25,
	S	=	26,
	SH	=	27,
	T	=	28,
	TH	=	29,
	TT	=	30,
	U	=	31,
	V	=	32,
	W	=	33,
	Y	=	34,
	Z	=	35,
	_i	=	36,
	_tH	=	37,
};

struct Laddie
{
	struct Header
	{
		int64 fileName <comment="StrCode64 hash of the file name, string embedded in .wem file">;
		int keyCount;
		short offsetToKey[keyCount] <bgcolor=0x94A6AA>;
		
	} header;

	if (FTell() % 4 != 0)
		FSkip(4-FTell() % 4);
	
	struct Keys
	{
		ushort unknown0 <fgcolor=0xFF0000, bgcolor=0x87E7FF>;
		ushort unknown1 <fgcolor=0x0000FF, bgcolor=0x87E7FF>;
		byte lipAnimCount <bgcolor=0xB9C199>; Assert(lipAnimCount==3,"Laddie keyZero lipAnimCount isn't right!!!");
		FSkip(3);
		int keyZeroParam0 <bgcolor=0xB9C199>;
		int realKeyCount <bgcolor=0xB9C199>;
		int keyZeroParam2 <bgcolor=0xB9C199>;
		
		struct Key
		{
			ushort unknown0 <fgcolor=0xFF0000, bgcolor=0x87E7FF>;
			ushort unknown1 <fgcolor=0x0000FF, bgcolor=0x87E7FF>;
			byte lipAnimCount <bgcolor=0xB8F8EB>;
			byte unknownFloatCount <bgcolor=0xA3D0D1>;
			FSkip(2);
			LipAnimIndex lipAnimIndex[lipAnimCount] <bgcolor=0xB8F8EB>;
			float unknownFloat[unknownFloatCount] <bgcolor=0xA3D0D1>;
		} key[realKeyCount] <optimize=false>;
		
	} keys;

	if (FTell() % 16 != 0)
		FSkip(16 - (FTell() % 16));
};

enum <byte> ObjectType{
	Settings=1,
	Sound=2,
	EventAction=3,
	Event=4,
	SequenceContainer=5,
	SwitchContainer=6,
	ActorMixer=7,
	AudioBus=8,
	BlendContainer=9,
	MusicSegment=10,
	MusicTrack=11,
	MusicSwitchContainer=12,
	MusicPlaylistContainer=13,
	Attenuation=14,
	DialogueEvent=15,
	MotionBus=16,
	MotionFX=17,
	Effect=18,
	Unknown=19,
	AuxillaryBus=20,
};

struct BankHeader
{
	int sectionSize;
	local int startOfSection = FTell();
	int soundBankVersion <comment="TPP is 88">;
	uint soundBankId <comment="FNV132 hash of the .sbp name">; 
	int unknown0 <comment="12 in TPP/MGO vox/SSD, 0 in MGO bgm/GZ/PT?">;
	int unknown1 <comment="Usually 1?">;
	int unknown2 <comment="Varies?">;
	FSkip((sectionSize+startOfSection)-FTell()); //Different with more padding in PS3 vox_hideo? Unreasonably huge padding size in PT/sh soundbanks
};

enum <byte> SoundStrctureParameterType
{
	GeneralSettingsVoiceVolume=0,
	GeneralSettingsVoicePitch=2,
	GeneralSettingsVoiceLowPassFilter=3,
	AdvancedSettingsPlaybackPriorityPriority=5,
	AdvancedSettingsPlaybackPriorityOffsetPriorityByMaxDistance=6,
	Loop=7,
	MotionAudioToMotionSettingsMotionVolumeOffset=8,
	Positioning2DPannerXCoordinate=11,
	Positioning2DPannerXCoordinate2=12,
	PositioningCenterPercent=13,
	GeneralSettingsUserDefinedAuxillarySendsBus0Volume=18,
	GeneralSettingsUserDefinedAuxillarySendsBus1Volume=19,
	GeneralSettingsUserDefinedAuxillarySendsBus2Volume=20,
	GeneralSettingsUserDefinedAuxillarySendsBus3Volume=21,
	GeneralSettingsGameDefinedAuxillarySendsVolume=22,
	GeneralSettingsOutputBusVolume=23,
	GeneralSettingsOutputBusLowPassFilter=24,
};

enum <byte> CoordinateDimension
{
	Pos2D=0,
	Pos3D=1,
};

enum <uint> PositionSourceType
{
	UserDefined=2,
	GameDefined=3,
};

enum <uint> PlayType
{
	SequenceStep=0,
	RandomStep=1,
	SequenceContinuous=2,
	RandomContinuout=3,
	SequenceStepPickNewPathWhenStarts=4,
	RandomStepPickNewPathWhenStarts=5,
};

struct SoundStructure
{
	byte overrideParentSettings;
	byte effectsCount;
	if (effectsCount>0)
		byte bypassEffectBitmask;
	
	struct SoundStrctureEffects
	{
		byte effectIndex;
		uint effectObjectId;
		FSkip(2);
		
	} soundStructureEffects[effectsCount];
	
	uint outputBusId;
	uint parentObjectId;
	byte overrideSettingsForPlaybackPriority;
	byte activateOffsetPriorityByDistanceSetting;
	byte additionalParametersCount;
	
	SoundStrctureParameterType additionalParameters[additionalParametersCount];
    local int index;
    for (index = 0; index < additionalParametersCount; index++)
	{
		if (additionalParameters[index]==7)
			uint32 parameterValueInt;
		else
			float parameterValueFloat;
	}
	
	FSkip(1);
	byte includePositioningSection;
	if (includePositioningSection == 1)
	{
		CoordinateDimension coordinateDimension;
		if (coordinateDimension==Pos2D)
			byte enablePanner;
		else if (coordinateDimension==Pos3D)
		{
			PositionSourceType positionSourceType;
			uint attenuationObjectId;
			byte enableSpatialization;
			if (positionSourceType==UserDefined)
			{
				PlayType playType;
				byte isLoop;
				uint transitionTime;
				byte followListenerOrientation;
			}
			else if (positionSourceType==GameDefined)
				byte updateAtEachFrame;
		}
	}
	byte overrideParentSettingsForGameDefinedAuxillarySends;
	byte useGameDefinedAuxillarySends;
	byte overrideParentSettingsForUserDefinedAuxillarySends;
	byte isUserDefinedAuxillarySends;
	if (isUserDefinedAuxillarySends==1)
	{
		uint auxillaryBus0Id;
		uint auxillaryBus1Id;
		uint auxillaryBus2Id;
		uint auxillaryBus3Id;
	}
	byte unknownParameterForPlaybackLimitSection;
	if (unknownParameterForPlaybackLimitSection>0)
	{
		byte oldOrNewInstanceToDiscard;
		byte killVoiceOrUseVirtualVoiceSettings;
		ushort limitSoundInstancesTo;
	}
	byte howToLimitSoundInstances;
	byte virtualVoiceBehavior;
	byte overrideParentSettingsForPlaybackLimitSection;
	byte overrideParentSettingsForVirtualVoiceSection;
	
	//This stuff is different from the xentax article:
	byte unknownCount0;
	byte unknownCount1;
	byte unknownCount2;
	byte unknownCount3;
	
	// TODO!!!!
	if (unknownCount0>0)
	{
		struct UnknownParams1
		{
			byte u1;
			short unk1;
			int unknown1;
			int unknown2[unk1];
		} unknownParams1[unknownCount1] <optimize=false>;
		struct UnknownParams2
		{
			byte u0;
			short unk0;
			struct SubParam1
			{
				float unknown0;
				float unknown1;
				int unknown2;
			} subParam[unk0];
			int unknown0;
			int unknown1;
			int unknown2;
		} unknownParams2[unknownCount2] <optimize=false>;
		struct UnknownParams3
		{
			byte u0;
			short unk0;
			struct SubParam3
			{
				float unknown0;
				float unknown1;
				int unknown2;
			} subParam[unk0];
		} unknownParams3[unknownCount3] <optimize=false>;
	}
	
	uint rtpcCount;
	struct Rtpc
	{
		float unknown4;
		byte unknown0;
		ushort unknown1;
		uint unknown2;
		uint unknown3;
	} rtpc[rtpcCount];
	if (unknownCount0==0)
	{
		FSkip(6);
	}
};

enum <byte> ObjectSettingsType
{
	VoiceVolume=0,
	VoiceLowPassFilter=3,
};

enum <int> ObjectSoundEmbedOrStream
{
	Embedded=0,
	Streamed=1,
	StreamedZeroLatency=2,
};

enum <byte> ObjectSoundType
{
	SFX=0,
	Voice=1,
};

struct Object
{
	ObjectType objectType;
	int objectSize;
	uint objectId <comment="FNV132 hash">; 
	if (objectType==Settings)
	{
		byte settingsCount;
		ObjectSettingsType settingType[settingsCount];
		float settingValue[settingsCount];
	}
/* 	else if (objectType==Sound)
	{
		uint flagsUnknown;
		ObjectSoundEmbedOrStream embedOrStream;
		uint audioFileId;
		uint sourceId <comment="If streamed, same as audioFileId. If embedded, the soundBankId.">;
		if (embedOrStream==Embedded)
		{
			int offsetToSoundFile;
			int lengthOfSoundFile;
		}
		ObjectSoundType soundType;
		SoundStructure soundStructure <optimize=false>;
	} */
/* 	else if (objectType==ActorMixer)
	{
		byte u0;
		byte u1;
		uint unknown6;
		FSkip(3);
		byte u2;
		byte u3;
		FSkip(1);
		byte u11;
		byte u12;
		byte u13;
		byte u14;
		byte u4;
		uint unknown0;
		uint unknown1;
		FSkip(2);
		byte u5;
		byte u6;
		float unknown2;
		float unknown7;
		FSkip(2);
		byte u7;
		FSkip(2);
		ushort unk0;
		byte u8;
		byte u9;
		byte u10;
		FSkip(15);
		int soundObjectIdsCount;
		uint soundObjectId[soundObjectIdsCount];
	} */
	else if (objectType==DialogueEvent)
	{
		struct DialogueEventObject{
			byte unknown0;
			uint unknown1;
			
			uint unknown2;
			uint unknown3;
			
			byte unknown4;
			byte unknown5;
			
			uint sizeOfEntryArray;
			
			byte unknown7;
			
			struct DialogueEventEntr0
			{
				uint empty;
				ushort unk2;
				ushort unk3;
				ushort unk0;
				ushort unk1;
				
			} dialogueEventEntr0[unknown4];
			
			struct DialogueEventVoiceType
			{
				uint voiceType;
				ushort unk2;
				ushort unk3;
				ushort unk0;
				ushort unk1;
				
			} dialogueEventVoiceType[unknown5];
			
			struct DialogueEventEntry
			{
				uint voiceId;
				uint wemId;
				ushort unk0;
				ushort unk1;
			} dialogueEntry[(sizeOfEntryArray/12)-(unknown4+unknown5)] <optimize=false>;
			
		} dialogueEventObject;
	}
	else
		char objectContent[objectSize-4] <comment="TO-DO">;
};

struct Hierarchy
{
	int sectionSize;
	int objectCount;
	Object object[objectCount] <optimize=false>;
};

struct StreamId
{
	int sectionSize;
	int unknown0;
	int streamIdsCount;
	struct StreamIds
	{
		uint streamId <comment="FNV132 hash of the following string">; 
		ubyte streamIdStringLength;
		char streamIdString[streamIdStringLength];
		
	} streamIds[streamIdsCount] <optimize=false>;
	
};

struct StreamedPackage
{
	char sign[4];
	short wemCount;
	byte hasLipSync;
	FSkip(1);
	
	struct StreamedWemDefiniton
	{
		uint streamedPackageId <comment="FNV132 hash?">;
		int offsetToWem;
		if (hasLipSync==1)
			int offsetToLip;
		
	} streamedWemDefinition[wemCount];
	
	if (FTell() % 16 != 0)
		FSkip(16 - (FTell() % 16));
	
	local int index = 0;
	struct RiffStreamed
	{
		local int preLipIndexCheck = FTell();
		if (hasLipSync==1)
		{
			if ((streamedWemDefinition[index].offsetToWem-streamedWemDefinition[index].offsetToLip)>0)
				Laddie lipFile;
			Assert(FTell()-(streamedWemDefinition[index].offsetToWem-streamedWemDefinition[index].offsetToLip)==preLipIndexCheck,"Laddie didn't parse all!!!");
		}
		
		local int size = 0;
		if (index+1<wemCount)
			if (hasLipSync==1)
				size = (streamedWemDefinition[index+1].offsetToLip-streamedWemDefinition[index].offsetToWem);
			else
				size = (streamedWemDefinition[index+1].offsetToWem-streamedWemDefinition[index].offsetToWem);
		else
			size = (endOfStp-streamedWemDefinition[index].offsetToWem);
		
		char riffData[size];
		
		index+=1;
		
	} riffStreamed[wemCount] <optimize=false>;
};

struct DataIndex
{
	int offsetsSize;
	struct EmbeddedWemDefinition
	{
		uint wemName <comment="FNV132 hash?">;
		int offsetToStart;
		int size;
		
	} embeddedWemDefiniton[offsetsSize/12];
	//DATA+garbage4bytes only appears if the definitions don't end up with an aligned stream????
	if (FTell() % 16 != 0)
		FSkip(16 - (FTell() % 16));
	
	local int index = 0;
	local int startOfArray = FTell();
	struct RiffEmbed
	{
		// ok seems to be inconsistent between GZ, TPP and SBP_Tool output as to whether it wants to align te stream
		// so this might leave the riff files with empty bytes at the start
		FSkip((startOfArray+embeddedWemDefiniton[index].offsetToStart)-FTell());
		
		char riffData[embeddedWemDefiniton[index].size];
		
		index+=1;
		
	} riffEmbed[offsetsSize/12] <optimize=false>;
};

struct SoundBankHeader
{
	char sign[4]; 
	if (sign == "SBPL")
	{
		LittleEndian();
	}
	else if (sign == "SBPB")
	{
		BigEndian();
	}
	
	ubyte sectionCount;
	ubyte bytesToSectionDefinitions;
	FSkip(2);
	struct SectionDefinition
	{
		char sign[4]; // "bnk" or "sab" or "stp"
		int offsetToSection;
		int sectionSize;
		
	} sectionDefinition[sectionCount];
	
	Assert(bytesToSectionDefinitions==FTell(),"SectionDefinitions size incorrect!!!");
	
} soundBankHeader <bgcolor=0x636F13>;

if (FTell() % 16 != 0)
	FSkip(16 - (FTell() % 16));

local int currentSection = 0;
local int startOfSection = FTell();
local int endOfStp = 0;

struct Sections
{
	startOfSection = FTell();
	Assert(soundBankHeader.sectionDefinition[currentSection].offsetToSection==FTell(),"Offset to start of Section is incorrect!!!!");
	
	if (soundBankHeader.sectionDefinition[currentSection].sign == "bnk")
	{
		while (FTell()<startOfSection+soundBankHeader.sectionDefinition[currentSection].sectionSize)
		struct Section0 {
			char sign[4];
			if (sign == "BKHD")
			{
				BankHeader bankHeader <bgcolor=0x3CCAE0, comment="Bank Header">;
			}
			else if (sign == "HIRC")
			{
				Hierarchy hierarchy <bgcolor=0x1342F3, comment="Object Hierarchy">;
			} 
			else if (sign == "STID")
			{
				StreamId streamId <bgcolor=0x5B2F3E, comment="Stream Ids">;
			}
			else if (sign == "DIDX")
			{
				DataIndex dataIndex <bgcolor=0x5B2F3E, comment="Embedded .wem sounds">;
			}
			else 
			{
				Assert(2+2==5,"Unknown section!!!!!");
			}
			
		} section0;
		
		if (FTell() % 16 != 0)
			FSkip(16 - (FTell() % 16));
		
	}
	else if (soundBankHeader.sectionDefinition[currentSection].sign == "sab")
	{
		struct StreamAnimationLip
		{
			char sign[4];
			int entryCount;
			
			struct Sa3Params
			{
				uint64 fileName <comment="StrCode64 hash of the file name, string embedded in .wem file, *not* tolowered", bgcolor=0x776C7C>;
				int offsetToEntryStart <bgcolor=0x94A6AA>;
				FSkip(4);
				
			} sa3Params[entryCount];
			
			struct Sa3Entry
			{
				int subEntryCount;//2
				struct SubEntryData{
					char entryType[];
					FSkip(1);
					int offsetToEntry;
				} subEntryData[subEntryCount] <bgcolor=0x776C7C>;
				
				local int index = 0;
				
				struct SubEntry
				{
					if (subEntryData[index].entryType=="ls")
					{
						struct KeysGZ
						{
							int keyCount <comment="Key count including metadata key zero">;
							short offsetsToKeys[keyCount] <comment="Offset from keyCount", bgcolor=0x94A6AA>;
							//vox_player_common.sbp TPP-only: <
							// if (FTell() % 4 != 0)
								// FSkip(4 - FTell() % 4);
							//>
							
							ushort unk0 <fgcolor=0xFF0000, bgcolor=0x87E7FF>;
							ushort unk1 <fgcolor=0x0000FF, bgcolor=0x87E7FF>;
							byte paramsCount <bgcolor=0xB9C199>;
							FSkip(3);
							if (paramsCount>0)
								int keyZeroParam0 <bgcolor=0xB9C199>;
							if (paramsCount>1)
								int realKeyCount <bgcolor=0xB9C199>;
							if (paramsCount>2)
								int keyZeroParam2 <bgcolor=0xB9C199>;
										
							struct KeyGZ
							{
								ushort unk0 <fgcolor=0xFF0000, bgcolor=0x87E7FF>;
								ushort unk1 <fgcolor=0x0000FF, bgcolor=0x87E7FF>;
								byte lipGzAnimCount <bgcolor=0xB8F8EB>;
								byte unknownFloatCount <bgcolor=0xA3D0D1>;
								FSkip(2);
								LipAnimIndex lipAnimIndexGz[lipGzAnimCount] <bgcolor=0xB8F8EB,optimize=false>;
								float unknownFloat[unknownFloatCount] <bgcolor=0xA3D0D1>;
								
							} keyGZ[realKeyCount] <optimize=false>;
							
							//vox_player_common.sbp TPP-only: <
							// FSkip(1);
							// if (FTell() % 8 != 0)
								// FSkip((8 - (FTell() % 8)-2));
							//>
							
						} keysGZ <optimize=false>;
					}
					else if (subEntryData[index].entryType=="st")
					{
						struct MessageIdSection
						{
							int unknown0 <bgcolor=0x58D7E9>;
							ushort unk0 <bgcolor=0x58D7E9>;
							int unknown1 <bgcolor=0x58D7E9>;
							ushort unk1 <bgcolor=0x58D7E9>;
							ushort unk2 <bgcolor=0x58D7E9>;
							int unknown3 <bgcolor=0x58D7E9>;
							char messageId[] <bgcolor=0x737329>;
							
							if (FTell() % 4 != 0)
								FSkip(4 - FTell() % 4);
							
						} messageIdSection <optimize=false>;
					};
					int64 fileNameAgain;
					
					if (FTell() % 16 != 0)
						FSkip(16 - (FTell() % 16));
					
					index+=1;
				
				} subEntry[subEntryCount] <optimize=false>;
				
			} sa3Entry[entryCount] <optimize=false>;
			
		} streamAnimationLip;
	}
	else if (soundBankHeader.sectionDefinition[currentSection].sign == "stp")
	{
		endOfStp = soundBankHeader.sectionDefinition[currentSection].sectionSize;
		struct Section2
		{
			StreamedPackage streamedPackage <bgcolor=0x5B2F3E, comment="Streamed .wem sounds">;
			
		} section2;
	};
	
	currentSection += 1;
	
} sections[soundBankHeader.sectionCount] <optimize=false>;
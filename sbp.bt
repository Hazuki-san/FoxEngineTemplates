// SBP - SoundBank Package
// By RLC, based on: https://wiki.xentax.com/index.php/Wwise_SoundBank_(*.bnk) https://github.com/secaproject/SBP_tool

enum <byte> ObjectType{
	Settings=1,
	Sound=2,
	EventAction=3,
	Event=4,
	SequenceContainer=5,
	SwitchContainer=6,
	ActorMixer=7,
	AudioBus=8,
	BlendContainer=9,
	MusicSegment=10,
	MusicTrack=11,
	MusicSwitchContainer=12,
	MusicPlaylistContainer=13,
	Attenuation=14,
	DialogueEvent=15,
	MotionBus=16,
	MotionFX=17,
	Effect=18,
	Unknown=19,
	AuxillaryBus=20,
};

struct BankHeader
{
	int sectionSize;
	local int startOfSection = FTell();
	int soundBankVersion <comment="TPP is 88">;
	uint soundBankId <comment="FNV132 hash of the .sbp name">; 
	int unknown0 <comment="12 in TPP/MGO vox/SSD, 0 in MGO bgm/GZ/PT?">;
	int unknown1 <comment="Usually 1?">;
	int unknown2 <comment="Varies?">;
	FSkip((sectionSize+startOfSection)-FTell()); //Different with more padding in PS3 vox_hideo? Unreasonably huge padding size in PT/sh soundbanks
};

enum <byte> SoundStrctureParameterType
{
	GeneralSettingsVoiceVolume=0,
	GeneralSettingsVoicePitch=2,
	GeneralSettingsVoiceLowPassFilter=3,
	AdvancedSettingsPlaybackPriorityPriority=5,
	AdvancedSettingsPlaybackPriorityOffsetPriorityByMaxDistance=6,
	Loop=7,
	MotionAudioToMotionSettingsMotionVolumeOffset=8,
	Positioning2DPannerXCoordinate=11,
	Positioning2DPannerXCoordinate2=12,
	PositioningCenterPercent=13,
	GeneralSettingsUserDefinedAuxillarySendsBus0Volume=18,
	GeneralSettingsUserDefinedAuxillarySendsBus1Volume=19,
	GeneralSettingsUserDefinedAuxillarySendsBus2Volume=20,
	GeneralSettingsUserDefinedAuxillarySendsBus3Volume=21,
	GeneralSettingsGameDefinedAuxillarySendsVolume=22,
	GeneralSettingsOutputBusVolume=23,
	GeneralSettingsOutputBusLowPassFilter=24,
};

enum <byte> CoordinateDimension
{
	Pos2D=0,
	Pos3D=1,
};

enum <uint> PositionSourceType
{
	UserDefined=2,
	GameDefined=3,
};

enum <uint> PlayType
{
	SequenceStep=0,
	RandomStep=1,
	SequenceContinuous=2,
	RandomContinuout=3,
	SequenceStepPickNewPathWhenStarts=4,
	RandomStepPickNewPathWhenStarts=5,
};

struct SoundStructure
{
	byte overrideParentSettings;
	byte effectsCount;
	if (effectsCount>0)
		byte bypassEffectBitmask;
	
	struct SoundStrctureEffects
	{
		byte effectIndex;
		uint effectObjectId;
		FSkip(2);
		
	} soundStructureEffects[effectsCount];
	
	uint outputBusId;
	uint parentObjectId;
	byte overrideSettingsForPlaybackPriority;
	byte activateOffsetPriorityByDistanceSetting;
	byte additionalParametersCount;
	
	SoundStrctureParameterType additionalParameters[additionalParametersCount];
    local int index;
    for (index = 0; index < additionalParametersCount; index++)
	{
		if (additionalParameters[index]==7)
			uint32 parameterValueInt;
		else
			float parameterValueFloat;
	}
	
	FSkip(1);
	byte includePositioningSection;
	if (includePositioningSection == 1)
	{
		CoordinateDimension coordinateDimension;
		if (coordinateDimension==Pos2D)
			byte enablePanner;
		else if (coordinateDimension==Pos3D)
		{
			PositionSourceType positionSourceType;
			uint attenuationObjectId;
			byte enableSpatialization;
			if (positionSourceType==UserDefined)
			{
				PlayType playType;
				byte isLoop;
				uint transitionTime;
				byte followListenerOrientation;
			}
			else if (positionSourceType==GameDefined)
				byte updateAtEachFrame;
		}
	}
	byte overrideParentSettingsForGameDefinedAuxillarySends;
	byte useGameDefinedAuxillarySends;
	byte overrideParentSettingsForUserDefinedAuxillarySends;
	byte isUserDefinedAuxillarySends;
	if (isUserDefinedAuxillarySends==1)
	{
		uint auxillaryBus0Id;
		uint auxillaryBus1Id;
		uint auxillaryBus2Id;
		uint auxillaryBus3Id;
	}
	byte unknownParameterForPlaybackLimitSection;
	if (unknownParameterForPlaybackLimitSection>0)
	{
		byte oldOrNewInstanceToDiscard;
		byte killVoiceOrUseVirtualVoiceSettings;
		ushort limitSoundInstancesTo;
	}
	byte howToLimitSoundInstances;
	byte virtualVoiceBehavior;
	byte overrideParentSettingsForPlaybackLimitSection;
	byte overrideParentSettingsForVirtualVoiceSection;
	
	//This stuff is different from the xentax article:
	byte unknownCount0;
	byte unknownCount1;
	byte unknownCount2;
	byte unknownCount3;
	
	// TODO!!!!
	if (unknownCount0>0)
	{
		struct UnknownParams1
		{
			byte u1;
			short unk1;
			int unknown1;
			int unknown2[unk1];
		} unknownParams1[unknownCount1] <optimize=false>;
		struct UnknownParams2
		{
			byte u0;
			short unk0;
			struct SubParam1
			{
				float unknown0;
				float unknown1;
				int unknown2;
			} subParam[unk0];
			int unknown0;
			int unknown1;
			int unknown2;
		} unknownParams2[unknownCount2] <optimize=false>;
		struct UnknownParams3
		{
			byte u0;
			short unk0;
			struct SubParam3
			{
				float unknown0;
				float unknown1;
				int unknown2;
			} subParam[unk0];
		} unknownParams3[unknownCount3] <optimize=false>;
	}
	
	uint rtpcCount;
	struct Rtpc
	{
		float unknown4;
		byte unknown0;
		ushort unknown1;
		uint unknown2;
		uint unknown3;
	} rtpc[rtpcCount];
	if (unknownCount0==0)
	{
		FSkip(6);
	}
};

enum <byte> ObjectSettingsType
{
	VoiceVolume=0,
	VoiceLowPassFilter=3,
};

enum <int> ObjectSoundEmbedOrStream
{
	Embedded=0,
	Streamed=1,
	StreamedZeroLatency=2,
};

enum <byte> ObjectSoundType
{
	SFX=0,
	Voice=1,
};

struct Object
{
	ObjectType objectType;
	int objectSize;
	uint objectId <comment="FNV132 hash">; 
	if (objectType==Settings)
	{
		byte settingsCount;
		ObjectSettingsType settingType[settingsCount];
		float settingValue[settingsCount];
	}
/* 	else if (objectType==Sound)
	{
		uint flagsUnknown;
		ObjectSoundEmbedOrStream embedOrStream;
		uint audioFileId;
		uint sourceId <comment="If streamed, same as audioFileId. If embedded, the soundBankId.">;
		if (embedOrStream==Embedded)
		{
			int offsetToSoundFile;
			int lengthOfSoundFile;
		}
		ObjectSoundType soundType;
		SoundStructure soundStructure <optimize=false>;
	} */
/* 	else if (objectType==ActorMixer)
	{
		byte u0;
		byte u1;
		uint unknown6;
		FSkip(3);
		byte u2;
		byte u3;
		FSkip(1);
		byte u11;
		byte u12;
		byte u13;
		byte u14;
		byte u4;
		uint unknown0;
		uint unknown1;
		FSkip(2);
		byte u5;
		byte u6;
		float unknown2;
		float unknown7;
		FSkip(2);
		byte u7;
		FSkip(2);
		ushort unk0;
		byte u8;
		byte u9;
		byte u10;
		FSkip(15);
		int soundObjectIdsCount;
		uint soundObjectId[soundObjectIdsCount];
	} */
	else if (objectType==DialogueEvent)
	{
		struct DialogueEventObject{
			byte unknown0;
			uint unknown1;
			
			uint unknown2;
			uint unknown3;
			
			byte unknown4;
			byte unknown5;
			
			uint sizeOfEntryArray;
			
			byte unknown7;
			
			struct DialogueEventEntr0
			{
				uint empty;
				ushort unk2;
				ushort unk3;
				ushort unk0;
				ushort unk1;
				
			} dialogueEventEntr0[unknown4];
			
			struct DialogueEventVoiceType
			{
				uint voiceType;
				ushort unk2;
				ushort unk3;
				ushort unk0;
				ushort unk1;
				
			} dialogueEventVoiceType[unknown5];
			
			struct DialogueEventEntry
			{
				uint voiceId;
				uint wemId;
				ushort unk0;
				ushort unk1;
			} dialogueEntry[(sizeOfEntryArray/12)-(unknown4+unknown5)] <optimize=false>;
			
		} dialogueEventObject;
	}
	else
		char objectContent[objectSize-4] <comment="TO-DO">;
};

struct Hierarchy
{
	int sectionSize;
	int objectCount;
	Object object[objectCount] <optimize=false>;
};

struct StreamId
{
	int sectionSize;
	int unknown0;
	int streamIdsCount;
	struct StreamIds
	{
		uint streamId <comment="FNV132 hash of the following string">; 
		ubyte streamIdStringLength;
		char streamIdString[streamIdStringLength];
		
	} streamIds[streamIdsCount] <optimize=false>;
	
};

struct StreamedPackage
{
	char sign[4];
	short wemCount;
	byte hasLipSync;
	FSkip(1);
	
	struct StreamedWemDefiniton
	{
		uint streamedPackageId <comment="FNV132 hash?">;
		int offsetToWem;
		if (hasLipSync==1)
			int offsetToLip;
		
	} streamedWemDefinition[wemCount];
	
	if (FTell() % 16 != 0)
		FSkip(16 - (FTell() % 16));
	
	local int index = 0;
	struct RiffStreamed
	{
		if (hasLipSync==1)
		{
			struct LipFile
			{
				char libBytes[streamedWemDefinition[index].offsetToWem-streamedWemDefinition[index].offsetToLip];
				
			} lipFile;
		}
		
		local int size = 0;
		if (index+1<wemCount)
			if (hasLipSync==1)
				size = (streamedWemDefinition[index+1].offsetToLip-streamedWemDefinition[index].offsetToWem);
			else
				size = (streamedWemDefinition[index+1].offsetToWem-streamedWemDefinition[index].offsetToWem);
		else
			size = (endOfStp-streamedWemDefinition[index].offsetToWem);
		
		char riffData[size];
		
		index+=1;
		
	} riffStreamed[wemCount] <optimize=false>;
};

struct DataIndex
{
	int offsetsSize;
	struct EmbeddedWemDefinition
	{
		uint wemName <comment="FNV132 hash?">;
		int offsetToStart;
		int size;
		
	} embeddedWemDefiniton[offsetsSize/12];
	//DATA+garbage4bytes only appears if the definitions don't end up with an aligned stream????
	if (FTell() % 16 != 0)
		FSkip(16 - (FTell() % 16));
	
	local int index = 0;
	local int startOfArray = FTell();
	struct RiffEmbed
	{
		// ok seems to be inconsistent between GZ, TPP and SBP_Tool output as to whether it wants to align te stream
		// so this might leave the riff files with empty bytes at the start
		FSkip((startOfArray+embeddedWemDefiniton[index].offsetToStart)-FTell());
		
		char riffData[embeddedWemDefiniton[index].size];
		
		index+=1;
		
	} riffEmbed[offsetsSize/12] <optimize=false>;
};

struct SoundBankHeader
{
	char sign[4]; 
	if (sign == "SBPL")
	{
		LittleEndian();
	}
	else if (sign == "SBPB")
	{
		BigEndian();
	}
	
	ubyte sectionCount;
	ubyte bytesToSectionDefinitions;
	FSkip(2);
	struct SectionDefinition
	{
		char sign[4]; // "bnk" or "sab" or "stp"
		int offsetToSection;
		int sectionSize;
		
	} sectionDefinition[sectionCount];
	
	Assert(bytesToSectionDefinitions==FTell(),"SectionDefinitions size incorrect!!!");
	
} soundBankHeader <bgcolor=0x636F13>;

if (FTell() % 16 != 0)
	FSkip(16 - (FTell() % 16));

local int currentSection = 0;
local int startOfSection = FTell();
local int endOfStp = 0;

struct Sections
{
	startOfSection = FTell();
	Assert(soundBankHeader.sectionDefinition[currentSection].offsetToSection==FTell(),"Offset to start of Section is incorrect!!!!");
	
	if (soundBankHeader.sectionDefinition[currentSection].sign == "bnk")
	{
		while (FTell()<startOfSection+soundBankHeader.sectionDefinition[currentSection].sectionSize)
		struct Section0 {
			char sign[4];
			if (sign == "BKHD")
			{
				BankHeader bankHeader <bgcolor=0x3CCAE0, comment="Bank Header">;
			}
			else if (sign == "HIRC")
			{
				Hierarchy hierarchy <bgcolor=0x1342F3, comment="Object Hierarchy">;
			} 
			else if (sign == "STID")
			{
				StreamId streamId <bgcolor=0x5B2F3E, comment="Stream Ids">;
			}
			else if (sign == "DIDX")
			{
				DataIndex dataIndex <bgcolor=0x5B2F3E, comment="Embedded .wem sounds">;
			}
			else 
			{
				Assert(2+2==5,"Unknown section!!!!!");
			}
			
		} section0;
		
		if (FTell() % 16 != 0)
			FSkip(16 - (FTell() % 16));
		
	}
	else if (soundBankHeader.sectionDefinition[currentSection].sign == "sab")
	{
		FSkip(soundBankHeader.sectionDefinition[currentSection].sectionSize);
/* 		struct Section1
		{
			char sign[4];
			int entryCount;
			struct Sa3Params
			{
				uint64 unknown0;
				int unknown1;
				int unknown2;
				
			} sa3Params[entryCount];
			struct Sa3Entry
			{
				// No idea lol
			} sa3Entry[entryCount];
			
		} section1; */
	}
	else if (soundBankHeader.sectionDefinition[currentSection].sign == "stp")
	{
		endOfStp = soundBankHeader.sectionDefinition[currentSection].sectionSize;
		struct Section2
		{
			StreamedPackage streamedPackage <bgcolor=0x5B2F3E, comment="Streamed .wem sounds">;
			
		} section2;
	};
	
	currentSection += 1;
	
} sections[soundBankHeader.sectionCount] <optimize=false>;
// https://github.com/oldbanana12/GeomsParser/blob/master/Geoms.cs

LittleEndian();

#define COLOR_HEADER 0xDFEFAA
#define COLOR_SECTION2 0x7DE39E
#define COLOR_ENTRY2 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_SECTION3 0xB9E8DD


struct Float3
{
    float x;
    float y;
    float z;
};

struct Float4
{
    float x;
    float y;
    float z;
    float w;
};

struct Quad
{
	ushort indices[4];
};

struct SubVerticesChunk
{
	uint verticesCount;
	uint unknown_params[3];
	uint u1;
	
	// always zero.
	FSkip(12);
	// another line of zeroes.
	FSkip(16);
	
	Float4 vertices[verticesCount-1];
};

struct FaceChunk
{
    local uint quadCount = (DataChunkID & 0xff000000) >> 24;
	
	// always zero, so skip 'em.
	FSkip(12);
	uint vals[4];

    local uint _i;
    for (_i = 0; _i < quadCount; _i++)
    {
        Quad quadIndices;
        FSkip(2);
    }

    // 16-byte alignment
    if (FTell() % 16 != 0)
    {
        FSkip(16 - (FTell() % 16));
    }
	
	// there's some cases where there isn't enough space for a
	// sub vertices chunk because there's only 2 lines of the
	// file left. this check makes sure we don't make a sub
	// vertices chunk if that happens (this doesn't work most
	// of the time though, but just ignore the error).
	if ( FTell() + 32 < header.FileSize )
	{
		// dirty hack: check if the number of vertices is way too
		// ridiculous to be true. if it's normal, then it's surely a
		// vertices count.
		if ( (ReadUInt() & 0xFFFF0000) == 0x0 )
		{
			SubVerticesChunk subverticeschunk;
		}
	}
};

struct DataChunk
{
    uint DataChunkID;

	// make sure we don't make any more headway in the data chunk if we've
	// clearly hit the end of the file.
	if ( FTell() + 32 < header.FileSize )
	{
		// spotted a weird case where a first wasn't 0x01020004, but it had
		// one bit that was the same in 0x01020004, so i'm adding that
		// to the check.
		if (DataChunkID == 0x01020004 || ( DataChunkID & 0x4 ) == 0x4 )
		{
			Printf("Position chunk");
			Printf( " (0x%LX)\n",FTell() );
			uint Vals[28/4];
	
			Float4 p1;
			Float4 p2;
		}
		else if ((DataChunkID & 0x00000002) == 0x00000002 && (DataChunkID & 0xff000000) != 0)
		{
			Printf("Index buffer");
			Printf( " (0x%LX)\n",FTell() );
			FaceChunk facechunk;
		}
	}
};

struct Chunk16
{
    uint Vals[4];
    uint DataChunkOffset;
    uint DataBlobSize;
    uint Unknown[DataBlobSize / sizeof(uint)];
};

struct BytePairs
{
	byte SB1;
	byte SB2;
};

// the continuation of Chunk10
struct Chunk10_Subsection1
{
	Float3 Vector;
	uint UI1;
	
	uint UI2;
	uint UI2;
	
	// the ps3 files with different endianness proves this is
	// an int64.
	int64 L1;
	
    // JOEY: Huge guess: perhaps Section2Offset aka 'section1_endPointOffset' is the size of the byte pairs blob?
    BytePairs Pairs[chunk10.BytePairsCount / 2];
};

struct Chunk10_Subsection2_Parts
{
	// all these data types must be correct, they've been
	// compared to the ps3 counterparts that have different
	// endianness.
	FSkip(1);
	byte B1;
	ushort UnknownCount; // HWL: "Unknown counter"
	
	ushort US2;
	FSkip(2);
	
	ushort US3;
	FSkip(2);
	
	int I1;
	int I2;
	int I3;
	double D1;
};

struct Chunk10_Subsection2
{
	Chunk10_Subsection2_Parts chunk10subsection2parts[chunk10.Section2Count] <optimize=false>;
};

struct Chunk10_Subsection3
{
	byte magic_byte;
	
	// padding stuff.
	FSkip(3);
	FSkip(28);
	
	FSkip(1);
	
	// as far as i can tell byte_pair1[0]
	// and byte_pair1[1] are the same.
	byte byte_pair1[3];
	local byte terminatorCount = byte_pair1[0] - 1 - 1; // -1 because i1
														// always exists.
	local byte terminatorCountActive = terminatorCount;
	
	int i1;
	FSkip(8);
	
	while ( terminatorCountActive > 0 )
	{
		// is what we're reading an actual number and
		// not just padding?
		if ( ReadUInt() != 0 )
		{
			int i;
			terminatorCountActive -= 1;
		}
		// if it is padding, then skip it.
		else FSkip(4);
	}
	
	// if we're finished with the int reading section, then keep
	// reading until we hit the first data chunk.
	if ( terminatorCountActive == 0 )
	{
		while ( ReadUInt() == 0 ) FSkip(4);
	}
};
struct Chunk10
{
    local long chunk10StartPos = FTell();

    Float3 P1;
    ushort BytePairsCount;
    ushort Section2Count;
    Float3 P2;
	uint Section2Offset;
	
	Chunk10_Subsection1 Section1<bgcolor=COLOR_ENTRY2>;

    FSeek(chunk10StartPos + Section2Offset);
	Chunk10_Subsection2 Section2<bgcolor=COLOR_CHUNK11>;
	Chunk10_Subsection3 Section3<bgcolor=COLOR_SECTION3>;
};


struct Chunk0
{
    uint Hash1;
    uint u2;
    uint Flag;
    uint NextSectionOffset;
	
	// i think it's a flag. but it's surely an int (or uint).
	uint Flag2;
};

struct Entry
{
	local long entryPosition = FTell();
	
    uint Hash1;
    uint u2;
    uint Flag;
    uint u4;
    uint u5;
    uint u6;
    uint NextSectionOffset; // Size of the header + padding
    ushort u8a;
    short u8b;
    uint NextEntryOffset; // Size of the entry + padding

    entryPosition += NextSectionOffset;
    FSeek(entryPosition);
    Chunk0 chunk0;

    // No more sections in the entry
    if (chunk0.NextSectionOffset == 0)
        break;

    // Next section
    entryPosition += chunk0.NextSectionOffset;
	FSeek(entryPosition);

	if (chunk0.Flag == 0)
	{
		Chunk10 chunk10;
	}
	else if (chunk0.Flag == 6)
	{
		Chunk16 chunk16<bgcolor=0xCCAA33>;

        entryPosition += chunk16.DataChunkOffset;
        FSeek(entryPosition);
	}
    else
    {
        Assert(false, "Unknown Entry section detected!");
    }

    local long bytesRemaining = 
        NextEntryOffset == 0 
        ? header.FileSize - entryPosition
        : header.Size + entry.NextEntryOffset - entryPosition;

    local long dataStartPosition = FTell();
    while (bytesRemaining != 0)
    {
        DataChunk Data;
        bytesRemaining -= FTell() - dataStartPosition;
        dataStartPosition = FTell();
    }
};

struct Header
{
    uint Version;
    uint Size;
    uint FileSize;

    uint u1;
    Assert(u1 == 7050094);

    uint u2 <hidden=true>;
    uint u3 <hidden=true>;
   
    Assert(u2 == 0);
    Assert(u3 == 0);

    uint Hash1;
    uint Hash2;
} header <bgcolor=COLOR_HEADER>;

local long startPosition = header.Size;
local long nextEntry = -1;

while (nextEntry != 0)
{
    startPosition = FTell();
    Entry entry <bgcolor=COLOR_SECTION2>;
    nextEntry = entry.NextEntryOffset;

    FSeek(startPosition + nextEntry);
}
LittleEndian();

/* Color defines. */
#define COLOR_HEADER 0x85CFCA
#define COLOR_UIMODELDATA 0x8CBA80
#define COLOR_SECTION_1 0x9C8E65
#define COLOR_STRCODE32 0x634651

#include "common/common.bt"

#define FILE_TYPE_MTAR2
#include "common/anim_common.bt"

struct Mtar2Header
{
	uint Version;

	uint FileCount;
	
	ushort TrackCount; // Same as FRIG

	ushort SegmentCount; // Same as FRIG

	uint Padding0 <hidden = true>; //Assert(Padding0 == 0);

	ushort Unknown;

	enum <ushort> MTAR_FLAGS
	{
		MTAR_FLAGS_NEW = 0x1000,

		MTAR_FLAGS_MTP_IS_BONE = 0x4000,
	} Flags; Assert((Flags & ~(MTAR_FLAGS_NEW | MTAR_FLAGS_MTP_IS_BONE)) == 0);

	uint CommonInfoOffset;

	uint64 Padding <hidden = true>; Assert(Padding == 0);
} Header <bgcolor = COLOR_HEADER>;

struct FileHeader
{
	PathCode64 Path; Assert((Path.hash >> 52) == (0xFC50 >> 4)); // Just confirming that these files are all GANIs by checking the extension

	uint DataOffset;

	ushort DataSize;

	ushort FkDataOffset;

	uint FkDataSize;

	uint Padding0;
	uint MotionEventsOffset;
	uint Padding1; Assert(Padding1 == 0);
} FileHeaders[Header.FileCount] <bgcolor = COLOR_UIMODELDATA, optimize = true>;

FSeek(Header.CommonInfoOffset);

typedef struct
{
	StrCode32 Name;

	uint DataSize;

	uint NextNodeOffset;

	uint Padding <hidden = true>; Assert(Padding == 0);
} Mtar2CompressedDataNode <bgcolor = COLOR_HEADER>;

struct Mtar2CommonInfo
{
	Mtar2CompressedDataNode LayoutTrackNode;

	TrackHeader LayoutTrack;

	if (LayoutTrackNode.NextNodeOffset != 0)
	{
		FSeek(startof(LayoutTrackNode) + LayoutTrackNode.NextNodeOffset);

		Mtar2CompressedDataNode MotionPointsNode;

		struct MotionPointsDef
		{
			uint Count <hidden = true>;

			if (Header.Flags & MTAR_FLAGS_MTP_IS_BONE)
			{
				enum <uint> BoneName_StrCode32Alias
				{
					SKL_000_cmon_tree001 = 574143535,
					SKL_001_cmon_tree001 = 901474389,
					SKL_002_cmon_tree001 = 736358179,
					SKL_003_cmon_tree001 = 2266581917,
					SKL_004_cmon_tree001 = 260712906,
				} BoneName[Count];
			}
			else
			{
				local uint bnAIdx;
				for (bnAIdx = 0; bnAIdx < Count; bnAIdx++)
				{
					struct Mtar2MTPBoneAssociation
					{
						StrCode32 MTPName;

						StrCode32 BoneName;
					} MTPBoneAssociation <optimize = true>;
				}
			}
		} MotionPoints;
	}
} CommonInfo <bgcolor = COLOR_STRCODE32>;

local uint flIdx;
for (flIdx = 0; flIdx < Header.FileCount; flIdx++)
{
	FSeek(FileHeaders[flIdx].DataOffset);

	struct Gani2File
	{
		struct Gani2TrackHeader
		{
			uint FrameCount;

			ubyte Padding0 <hidden = true>; Assert(Padding0 == 0);

			ubyte ParamCount;

			ushort Padding1 <hidden = true>; Assert(Padding1 == 0);

			local uint pIdx;
			for (pIdx = 0; pIdx < ParamCount; pIdx++)
			{
				struct Gani2Param
				{
					enum <uint> ParamName_StrCode32Alias
					{
						SLOPE_ANGLE = 35201703,
						SLOPE_DIR = 3426329078,
					} Name; Assert(Name == 35201703 || Name == 3426329078);
					float Value;
				} Param <read = Str("%s = %f", EnumToString(Name), Value)>;
			}

			TrackUnitFlags UnitFlags[Header.TrackCount];

			FAlign(4);

			struct Gani2TrackData
			{
				uint ComponentBitSize : 8;

				uint DataOffset : 24;
			} SegmentHeaders[Header.SegmentCount];

			FSkip(16);

			local uint tkIdx;
			local uint rlSgIdx;
			local uint sgIdx = 0;
			for (tkIdx = 0; tkIdx < Header.TrackCount; tkIdx++)
			{
				struct Gani2TrackUnit
				{
					for (rlSgIdx = 0; rlSgIdx < CommonInfo.LayoutTrack.Track[tkIdx].SegmentCount; rlSgIdx++, sgIdx++)
					{
						if (SegmentHeaders[sgIdx].DataOffset != 0)
						{
							FSeek(startof(SegmentHeaders[sgIdx]) + SegmentHeaders[sgIdx].DataOffset);

							TrackDataBlob Data(CommonInfo.LayoutTrack.Track[tkIdx].SegmentHeaders[rlSgIdx].Type, SegmentHeaders[sgIdx].ComponentBitSize, UnitFlags[tkIdx] & TRACK_UNIT_FLAGS_NO_FRAMES);
						}
					}
				} Track;
			}
		} Tracks;

		FAlign(16);

		if ((FileHeaders[flIdx].FkDataSize) != 0)
		{
			FSeek(startof(this) + FileHeaders[flIdx].FkDataOffset * 0x10);

			TrackHeader FkTracks;
		}

		if (FileHeaders[flIdx].MotionEventsOffset != 0)
		{
			FSeek(FileHeaders[flIdx].MotionEventsOffset);

			EvpGroup MotionEvents;
		}
	} File <bgcolor = COLOR_SECTION_1>;
}
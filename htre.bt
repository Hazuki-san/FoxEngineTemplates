LittleEndian();

#define COLOR_TEXT 0xe1e1e1
#define COLOR_HEADER 0x2c3940
#define COLOR_1 0x4e6c84
#define COLOR_2 0x7294a6
#define COLOR_3 0xb0cad9
#define COLOR_4 0xe1e1e1
#define COLOR_5 0xcad2c7
#define COLOR_6 0xa59f71
#define COLOR_7 0x7e6d41

typedef struct
{
    uint hash<format=hex>;
} StrCode32 <read=(hash)>;

typedef struct
{
    ubyte r<fgcolor=0xaaaaff>;
    ubyte g<fgcolor=0xaaffaa>;
    ubyte b<fgcolor=0xffaaaa>;
    ubyte a<fgcolor=0xaaaaaa>;
} Pixel <read=Str("#%02x%02x%02x%02x", r, g, b, a)>;

typedef struct
{
    ushort VariableType; // 0: uint, 2: float
    ushort NextMetadataOffset; //sizeof(HeaderMetadata0)
    StrCode32 NameHash;
    uint NameStringOffset;
    float Value;
} FloatMetadata <read=Str("(%s, %f)", HashLookup(NameHash), Value)>;

typedef struct
{
    ushort VariableType; // 0: uint, 2: float
    ushort NextMetadataOffset; // sizeof(HeaderMetadata0) or 0
    StrCode32 NameHash;
    uint NameStringOffset;
    uint Value;
} UIntMetadata <read=Str("(%s, %d)", HashLookup(NameHash), Value)>;

typedef struct
{
    local uint SelfStartPos = FTell();

    StrCode32 NameHash;
    uint NameStringOffsetRelative;
    uint Unknown<hidden=true>; // Only nonzero in HTRE Type==4 files
    uint DataOffset; // 0 means no data
    uint DataSize; // 0 means no data
    uint EditParamOffset;       // Only nonzero for configrationIds entry in HTRE Type==3 files
    uint ConfigrationIdsOffset; // exe searches for this entry, Only nonzero for editParam entry in HTRE Type==3 files
    int PreviousEntryOffset; // 0 means no previous entries
    int NextEntryOffset; // 0 means no more entries
    uint ScalarSubParamOffset; // 0 means no subparams
    uint padding2<hidden=true>; Assert(padding2 == 0);
    uint padding3<hidden=true>; Assert(padding3 == 0);
} TextureMetadata <read=Str("%s", HashLookup(NameHash))>;

struct
{
    uint Type;
    uint FirstSectionOffset; Assert(FirstSectionOffset == 0x20);
    uint FileSize;
    StrCode32 NameHash <read=HashLookup(this)>;
    uint NameStringOffset;

    FSeek(FirstSectionOffset);
} Header <bgcolor=0xaaaaaa>;

if (Header.Type == 3)
{
    // The header is identical in two random afgh and cypr htres.
    struct
    {
        TextureMetadata HeightMapDefinition<bgcolor=0xff9999>;
        UIntMetadata PitchParameter<bgcolor=0xff9900>;
    
        TextureMetadata WeightMapDefinition<bgcolor=0x999900>; // code mistakenly put "heightMap" twice

        TextureMetadata EditParamDefinition<bgcolor=0x0909ff>;
        UIntMetadata MaxLodLevelParameter<bgcolor=0xaacc99>;

        TextureMetadata LodParameterDefinition<bgcolor=0xffff99>;

        TextureMetadata MaxHeightDefinition<bgcolor=0x9999ff>;
    
        TextureMetadata MinHeightDefinition<bgcolor=0xff99ff>;
    
        TextureMetadata MaterialIdsDefinition<bgcolor=0x99ffff>;

        TextureMetadata ConfigrationIdsDefinition<bgcolor=0x99ff99>;
    } Metadata;

    FSeek(Metadata.HeightMapDefinition.SelfStartPos);
    FSkip(Metadata.HeightMapDefinition.DataOffset);
    struct
    {
        float data[Metadata.HeightMapDefinition.DataSize / sizeof(float)];
    } HeightMap <bgcolor=0x99aacc>;

    FSeek(Metadata.WeightMapDefinition.SelfStartPos);
    FSkip(Metadata.WeightMapDefinition.DataOffset);
    struct
    {
        Pixel data[Metadata.WeightMapDefinition.DataSize / sizeof(Pixel)];
    } WeightMap <bgcolor=0x111199>;

    FSeek(Metadata.LodParameterDefinition.SelfStartPos);
    FSkip(Metadata.LodParameterDefinition.DataOffset);
    struct
    {
        float data[Metadata.LodParameterDefinition.DataSize / sizeof(float)];
    } LodParameter <bgcolor=0x00aaff>;

    FSeek(Metadata.MaxHeightDefinition.SelfStartPos);
    FSkip(Metadata.MaxHeightDefinition.DataOffset);
    struct
    {
        float data[Metadata.MaxHeightDefinition.DataSize / sizeof(float)];
    } MaxHeight <bgcolor=0xff00aa>;

    FSeek(Metadata.MinHeightDefinition.SelfStartPos);
    FSkip(Metadata.MinHeightDefinition.DataOffset);
    struct
    {
        float data[Metadata.MinHeightDefinition.DataSize / sizeof(float)];
    } MinHeight <bgcolor=0xaaff00>;
    
    FSeek(Metadata.MaterialIdsDefinition.SelfStartPos);
    FSkip(Metadata.MaterialIdsDefinition.DataOffset);
    struct
    {
        Pixel data[Metadata.MaterialIdsDefinition.DataSize / sizeof(Pixel)];
    } MaterialIds <bgcolor=0x991111>;

    FSeek(Metadata.ConfigrationIdsDefinition.SelfStartPos);
    FSkip(Metadata.ConfigrationIdsDefinition.DataOffset);
    struct
    {
        Pixel data[Metadata.ConfigrationIdsDefinition.DataSize / sizeof(Pixel)];
    } ConfigrationIds <bgcolor=0x119911>;
}
else if (Header.Type == 4)
{
    struct
    {
        TextureMetadata HeightMapDefinition<bgcolor=0x999900>;
        UIntMetadata PitchParameter<bgcolor=0x99aacc>;
        UIntMetadata HeightFormatParameter<bgcolor=0x990099>;
        FloatMetadata HeightRangeMaxParameter<bgcolor=0xff0909>;
        FloatMetadata HeightRangeMinParameter<bgcolor=0x09ff09>;

        TextureMetadata ComboTextureDefinition<bgcolor=0x0909ff>;
        UIntMetadata ComboFormatParameter<bgcolor=0xaacc99>;

        TextureMetadata EditParamDefinition<bgcolor=0xccaa99>;
        UIntMetadata MaxLodLevelParameter<bgcolor=0xff0099>;

        TextureMetadata LodParameterDefinition<bgcolor=0xff9999>;

        TextureMetadata MaxHeightDefinition<bgcolor=0x9999ff>;

        TextureMetadata MinHeightDefinition<bgcolor=0xff99ff>;

        TextureMetadata MaterialIdsDefinition<bgcolor=0x99ffff>;

        TextureMetadata ConfigrationIdsDefinition<bgcolor=0x99ff99>;

        TextureMetadata PatchDescriptionDefinition<bgcolor=0xffff99>;
    } Metadata;

    FSeek(Metadata.PatchDescriptionDefinition.SelfStartPos);
    FSkip(Metadata.PatchDescriptionDefinition.DataOffset);
    struct
    {
        uint data[Metadata.PatchDescriptionDefinition.DataSize / sizeof(uint)];
    } PatchDescription <bgcolor=0x999900>;

    FSeek(Metadata.HeightMapDefinition.SelfStartPos);
    FSkip(Metadata.HeightMapDefinition.DataOffset);
    struct
    {
        float data[Metadata.HeightMapDefinition.DataSize / sizeof(float)];
    } HeightMap <bgcolor=0x99aacc>;

    FSeek(Metadata.ComboTextureDefinition.SelfStartPos);
    FSkip(Metadata.ComboTextureDefinition.DataOffset);
    struct
    {
        Pixel data[Metadata.ComboTextureDefinition.DataSize / sizeof(Pixel)];
    } ComboTexture <bgcolor=0x111199>;
    
    FSeek(Metadata.LodParameterDefinition.SelfStartPos);
    FSkip(Metadata.LodParameterDefinition.DataOffset);
    struct
    {
        float data[Metadata.LodParameterDefinition.DataSize / sizeof(float)];
    } LodParameter <bgcolor=0x00aaff>;

    FSeek(Metadata.MaxHeightDefinition.SelfStartPos);
    FSkip(Metadata.MaxHeightDefinition.DataOffset);
    struct
    {
        float data[Metadata.MaxHeightDefinition.DataSize / sizeof(float)];
    } MaxHeight <bgcolor=0xff00aa>;

    FSeek(Metadata.MinHeightDefinition.SelfStartPos);
    FSkip(Metadata.MinHeightDefinition.DataOffset);
    struct
    {
        float data[Metadata.MinHeightDefinition.DataSize / sizeof(float)];
    } MinHeight <bgcolor=0xaaff00>;
    
    FSeek(Metadata.MaterialIdsDefinition.SelfStartPos);
    FSkip(Metadata.MaterialIdsDefinition.DataOffset);
    struct
    {
        Pixel data[Metadata.MaterialIdsDefinition.DataSize / sizeof(Pixel)];
    } MaterialIds <bgcolor=0x991111>;

    FSeek(Metadata.ConfigrationIdsDefinition.SelfStartPos);
    FSkip(Metadata.ConfigrationIdsDefinition.DataOffset);
    struct
    {
        Pixel data[Metadata.ConfigrationIdsDefinition.DataSize / sizeof(Pixel)];
    } ConfigrationIds <bgcolor=0x119911>;
}

string HashLookup( StrCode32& hash )
{
 if( hash.hash == 2767142850 )
     return "terrainHighBlock";
 else if( hash.hash == 4283592115 )
     return "heightMap";
 else if( hash.hash == 1011123561 )
     return "pitch";
 else if( hash.hash == 3806600625 )
     return "editParam";
 else if( hash.hash == 443065316 )
     return "maxLodLevel";
 else if( hash.hash == 2901004164 )
     return "lodParameter";
 else if( hash.hash == 2170562455 )
     return "maxHeight";
 else if( hash.hash == 316436384 )
     return "minHeight";
 else if( hash.hash == 3214045617 )
     return "materialIds";
 else if( hash.hash == 2104978212 )
     return "configrationIds";
 else if( hash.hash == 3548226499 )
     return "heightFormat";
 else if( hash.hash == 4167755735 )
     return "heightRangeMax";
 else if( hash.hash == 3494717177 )
     return "heightRangeMin";
 else if( hash.hash == 1508369315 )
     return "comboTexture";
 else if( hash.hash == 2003906452 )
     return "comboFormat";
 else if( hash.hash == 734927665 )
     return "patchDescription";
 else
     return "";
}
LittleEndian();

#define COLOR_HEADER 0xDFEFAA
#define COLOR_ENTRY 0x7DE39E
#define COLOR_ENTRYSUBSECTION1 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_ENTRYMATERIALSECTION 0xB9E8DD
#define COLOR_BOUNDINGBOXCHUNK 0xF7F205

typedef struct
{
    uint hash<format=hex>;
} StrCode32 <read=(hash)>;

typedef struct 
{
    uint hash<format=hex>;
} MtrCode32 <read=(hash)>;

typedef struct
{
	float x;
	float y;
	float z;
} Float3 <read=Str("(%g, %g, %g)", x, y, z)>;

typedef struct
{
	float x;
	float y;
	float z;
	float w;
} Float4 <read=Str("(%g, %g, %g, %g)", x, y, z, w)>;

typedef struct
{
	ushort indices[4];
} Quad <read=Str("(%d, %d, %d, %d)", indices[0], indices[1], indices[2], indices[3])>;

void EntryCollisionFlag()
{
	uint64 CollisionFlags<format=binary, bgcolor=0xFF00FF, fgcolor=0x00FF00>;
}

struct SubVerticesChunk
{
	uint VertexCountPlusOne;

	if ( ( FTell() + (VertexCountPlusOne * 16) + 32 - 4 ) > Header.FileSize )
	{
		Printf("External geometry reference detected.");
		return;
	}
	
	uint UnknownUInts[3]; // Most often 1, 1 and 0
	
	local long CurrentPos = FTell();
	
	uint VertexOffset;
	FSeek( CurrentPos + VertexOffset );
	
	Float4 Vertices[VertexCountPlusOne - 1];
};

// Slightly incorrect because this does not flip based on endian-ness.
typedef struct
{
    enum <ubyte> DATA_CHUNK_TYPE
    {
        DATA_CHUNK_TYPE_UNKNOWN_0 = 0,
        DATA_CHUNK_TYPE_UNKNOWN_1 = 1,
        DATA_CHUNK_TYPE_INDICES = 2,
        DATA_CHUNK_TYPE_UNKNOWN_3 = 3,
        DATA_CHUNK_TYPE_BOUNDING_BOX = 4,
        DATA_CHUNK_TYPE_UNKNOWN_5 = 5,
        DATA_CHUNK_TYPE_UNKNOWN_6 = 6,
        DATA_CHUNK_TYPE_UNKNOWN_7 = 7,
        DATA_CHUNK_TYPE_UNKNOWN_8 = 8,
        DATA_CHUNK_TYPE_UNKNOWN_11 = 11,
    } Type;
    
    ushort UnknownFlags <format=binary>; // The exe checks if 0x200 isn't set. If it isn't, it does something. mgsvtpp.exe!141bdc492
    ubyte QuadCount;
} DataChunkInfo <read=(EnumToString(Type))>;

struct DataChunkHeader
{
	local uint SelfStartPos = FTell();

    DataChunkInfo Info<bgcolor=0x0080ff>;

	uint NextBBDataChunkLinesOffset;

	uint Unknown0;
	uint Unknown1;

	EntryCollisionFlag();

	uint Unknown2;
	uint Unknown3;
};

struct DataChunk
{
	local long SelfStartPos = FTell();

	DataChunkHeader Header;

	if (Header.Info.Type == DATA_CHUNK_TYPE_BOUNDING_BOX) 
	{
        SetBackColor(COLOR_BOUNDINGBOXCHUNK);
        {
	        Float4 BoundingBoxRadii <bgcolor=0xDBC48F, comment="Width/2, Height/2, Depth/2">;
	        Float4 BoundingBoxCenter <bgcolor=0xDBC48F>;
        }
        SetBackColor(cNone);
	}
	else if (Header.Info.Type == DATA_CHUNK_TYPE_INDICES)
	{
		local uint _i;
	    for (_i = 0; _i < Header.Info.QuadCount; _i++)
	    {
		    Quad QuadIndices;
		    short UnknownOffset <comment="Always negative.">;
	    }
	    
	    // HWL removed a very old if check as of v3.6.5.
    
	    // HWL a cleaner implementation of the sub vertices chunk, as of v3.6.3.
	    // instead of checking if the number of vertices is too ridiculous, we
	    // instead use the line_offset_to_vertices variable. then, the template
	    // "snaps" to that sub vertices chunk, and after it's done, it returns
	    // to the previous position.
	    // note: this doesn't happen if the sub vertices chunk is right underneath
	    // this face chunk.
		
	    // if (LinesOffsetToVertices > 0)
	    // {
		//     local long subVerticesChunkStartPos = (SelfStartPos + (LinesOffsetToVertices * 16) );
		    
		//     FSeek(subVerticesChunkStartPos);
		//     SubVerticesChunk Subverticeschunk;
	    // }
	}
    else
    {
        Assert(false, "Unknown DataChunk Type Detected!");
    }
};

struct ShortPairs
{
	short SS1;
	short SS2;
};

struct EntryDataChunkDefinition
{
	local uint SelfStartPos = FTell();

	byte IsFinalEntry;

	byte DataChunkCount;
	ushort TotalDataChunksSizeInBytes;
	
	ushort BoundingBoxOrSubverticesOffset;
	ushort Padding0 <hidden = true>; Assert(Padding0 == 0);
	
	ushort BoundingBoxOrSubverticesOffset;
	ushort Padding0 <hidden = true>; Assert(Padding0 == 0);
	
	uint SubverticesOffset;
	uint FirstDataChunkOffset;
	uint NextSectionOffset;
	
	EntryCollisionFlag();
};

struct DataChunkDefinitions
{
    local uint SelfStartPos;
    local uint i;
	local uint nextBBChunkPos;

    while(!ReadUByte())
	{
        SelfStartPos = FTell();

		EntryDataChunkDefinition Entry;

        FSeek(SelfStartPos + Entry.FirstDataChunkOffset);

        for (i = 0; i < Entry.DataChunkCount; i++)
        {
            DataChunk Data;
			nextBBChunkPos = Data.SelfStartPos + Data.Header.NextBBDataChunkLinesOffset * 16;

			if (Data.Header.NextBBDataChunkLinesOffset != 0)
			{
				DataChunk Data;
				i++;

				FSeek(nextBBChunkPos);
			}
        }

        FSeek(SelfStartPos + 32);
	};

	// Skip last "dummy" data chunk definition
    FSkip(32);
};

struct EntryMaterialsSection
{
	byte MagicByte <hidden=true>;
    Assert(MagicByte == 0);
	
	byte InfoTriplet[3] <comment="(Material Count+1, Material Count+1, 1).">;
    Assert(InfoTriplet[0] == InfoTriplet[1]);
    Assert(InfoTriplet[2] == 1);
	
    local uint i = 0;
    for (i = 0; i < (InfoTriplet[0] - 1); i++)
    {
		MtrCode32 MaterialNameHash;
		FSkip(8);
    }
};

enum GEOM_SECTION_TYPE
{
	GEOM_SECTION_TYPE_0 = 0,
	GEOM_SECTION_TYPE_6 = 6,
};

struct EntrySubsection1
{
	local uint SelfStartPos = FTell();

	Float3 EntryBoundingBoxCorner;
	ushort ShortPairsTotalSizeInBytes;
	ushort Section2Count;
	Float3 EntryBoundingBoxExtents;
	uint NextSectionOffset;

	Float3 Vector;
	uint UI1;
	
	uint UI2;
	uint UI2;
	
	EntryCollisionFlag();
	
	// HWL are they actually pairs?
	ShortPairs Pairs[ShortPairsTotalSizeInBytes / sizeof(ShortPairs)];
};

struct EntrySecondaryHeaderSection
{
	local uint SelfStartPos = FTell();

	StrCode32 Hash1;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);
	
	GEOM_SECTION_TYPE Type;
	Assert((SecondaryHeaderSection.Type == GEOM_SECTION_TYPE_0) || (SecondaryHeaderSection.Type == GEOM_SECTION_TYPE_6), "Unknown Entry section detected!");
	
    uint NextSectionOffset;
	
	uint SizeOfRemainingEntryData;
};

struct EntryHeaderSection
{
	local uint SelfStartPos = FTell();

    StrCode32 UnusedHash0;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);

	uint UnknownOffset; // mgsvtpp.exe!141bef7fa

	uint64 Padding1<hidden=true>; Assert(Padding1 == 0);
	uint Padding2<hidden=true>; Assert(Padding2 == 0);
	
	uint NextSectionOffset; // Size of the header + padding
	
	int PreviousEntryOffset; // The value stored is positive, but it's for jumping backwards in list.
	
	uint NextEntryOffset; // Size of the entry + padding
}; // mgsvtpp.exe!14cd19a40

struct
{
	uint Version;
	uint FirstEntryOffset;
	uint FileSize;

	uint u1 <hidden=true>; Assert(u1 == 7050094);

	uint64 Padding0<hidden=true>; Assert(Padding0 == 0);

	StrCode32 UnusedHash0;
	StrCode32 UnusedHash1;
} Header <bgcolor=COLOR_HEADER>; // mgsvtpp!141bef7b2

local uint DefinitionStartPos = Header.FirstEntryOffset;
do
{
	FSeek(DefinitionStartPos);

	struct
	{
		local uint SelfStartPos = FTell();
		
		EntryHeaderSection HeaderSection;
		
		FSeek(HeaderSection.SelfStartPos + HeaderSection.NextSectionOffset);

		EntrySecondaryHeaderSection SecondaryHeaderSection;

		if (SecondaryHeaderSection.NextSectionOffset == 0)
			break;
		FSeek(SecondaryHeaderSection.SelfStartPos + SecondaryHeaderSection.NextSectionOffset);
		
		if (SecondaryHeaderSection.Type == GEOM_SECTION_TYPE_0)
		{
			EntrySubsection1 Section1<bgcolor=COLOR_ENTRYSUBSECTION1>;
		
			FSeek(Section1.SelfStartPos + Section1.NextSectionOffset);
		}
		
		DataChunkDefinitions DataChunks<bgcolor=COLOR_CHUNK11>;
		
		EntryMaterialsSection Materials<bgcolor=COLOR_ENTRYMATERIALSECTION>;
	} CollisionDefinition <bgcolor=COLOR_ENTRY>;

	DefinitionStartPos = Header.FirstEntryOffset + CollisionDefinition.HeaderSection.NextEntryOffset;
} while (CollisionDefinition.HeaderSection.NextEntryOffset != 0);
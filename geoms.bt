LittleEndian();

#define COLOR_HEADER 0xDFEFAA
#define COLOR_ENTRY 0x7DE39E
#define COLOR_ENTRYBVHSECTION 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_ENTRYMATERIALSECTION 0xB9E8DD
#define COLOR_BOUNDINGBOXCHUNK 0xF7F205

typedef struct
{
    uint hash<format=hex>;
} StrCode32 <read=(hash)>;

typedef struct 
{
    uint hash<format=hex>;
} MtrCode32 <read=(hash)>;

typedef struct
{
	float x;
	float y;
	float z;
} Float3 <read=Str("(%g, %g, %g)", x, y, z)>;

typedef struct
{
	float x;
	float y;
	float z;
	float w;
} Float4 <read=Str("(%g, %g, %g, %g)", x, y, z, w)>;

// Intentionally asymmetric to make quickly reading through the list easier.
typedef enum <uint64> {
    SET = 1,
    _ = 0,
} BIT <read=EnumToString(this)>;

void ReadCollisionFlags()
{
	BitfieldDisablePadding();
	struct COLLISION_FLAGS
	{
		BIT UNKNOWN1 : 1; Printf("COLLISION_FLAGS::UNKNOWN1 set.\n");
		BIT RECOIL_FLOOR_MAYBE : 1;
		BIT UNKNOWN0 : 1; Printf("COLLISION_FLAGS::UNKNOWN0 set.\n");
		BIT CHARA_MAYBE : 1;

		BIT PLAYER : 1;
		BIT ENEMY : 1;
		BIT BULLET : 1;
		BIT MISSILE : 1;

		BIT BOMB : 1;
		BIT UNUSED5 : 1;
		BIT BLOOD : 1;
		BIT IK : 1;

		BIT STAIRWAY : 1;
		BIT STOP_EYE : 1;
		BIT CLIFF : 1;
		BIT UNUSED4 : 1; Assert(UNUSED4 == 0);

		BIT UNUSED6 : 1; Assert(UNUSED6 == 0);
		BIT DONT_FALL : 1;
		BIT CAMERA : 1;
		BIT UNUSED2 : 1; Assert(UNUSED2 == 0);

		BIT UNUSED1 : 1; Assert(UNUSED1 == 0);
		BIT UNUSED0 : 1; Assert(UNUSED0 == 0);
		BIT CLIFF_FLOOR : 1;
		BIT BULLET_MARK : 1;

		BIT HEIGHT_LIMIT : 1;
		BIT DOUBLE_SLIDE : 1;
		BIT WATER_SURFACE : 1;
		BIT TARGET_BLOCK : 1;

		BIT DOG : 1;
		BIT NO_EFFECT : 1;
		BIT EVENT_PHYSICS : 1;
		BIT NO_WALL_MOVE : 1;

		ushort Padding0 : 16 <hidden=true>; Assert(Padding0 == 0);

		BIT MISSILE2 : 1;
		BIT RIDE_ON_OUTER : 1;
		BIT FLAME : 1;
		BIT IGNORE_PHYSICS : 1;`

		BIT CLIMB : 1;
		BIT HORSE : 1;
		BIT VEHICLE : 1;
		BIT MARKER : 1;

		BIT RIDE_ON : 1;
		BIT THROUGH_LINE_OF_FIRE : 1;
		BIT THROUGH_ITEM_CHECK : 1;
		BIT NO_CREEP : 1;

		BIT NO_FULTON : 1;
		BIT FULTON : 1;
		BIT ITEM : 1;
		BIT BOSS : 1;
	} CollisionFlags <bgcolor=0xFF00FF, fgcolor=0x00FF00>;
	BitfieldEnablePadding();
}

enum <byte> DATA_CHUNK_TYPE
{
	DATA_CHUNK_TYPE_UNKNOWN_0 = 0,   	// Entry size: 0x30
	DATA_CHUNK_TYPE_UNKNOWN_1 = 1,		// Entry size: 0x30
	DATA_CHUNK_TYPE_INDICES = 2,		// Entry size: 0xA
	DATA_CHUNK_TYPE_UNKNOWN_3 = 3,		// Entry size: 0x60
	DATA_CHUNK_TYPE_BOUNDING_BOX = 4,	// Entry size: 0x20
	DATA_CHUNK_TYPE_UNKNOWN_5 = 5,		// Entry size: 0x80
	DATA_CHUNK_TYPE_UNKNOWN_6 = 6,		// Entry size: 0
	DATA_CHUNK_TYPE_UNKNOWN_7 = 7,		// Entry size: 0
	DATA_CHUNK_TYPE_UNKNOWN_8 = 8,		// Entry size: 0x8
	DATA_CHUNK_TYPE_UNKNOWN_11 = 11,	// Entry size: 0x10
};

struct DataChunkHeader
{
	local uint SelfStartPos = FTell();

	BitfieldDisablePadding();
    DATA_CHUNK_TYPE Type : 4 <bgcolor=0x0080ff>;

	ubyte Padding0 : 4 <hidden = true>; Assert(Padding0 == 0);

    enum <ushort> DATA_CHUNK_FLAGS
    {
        DATA_CHUNK_FLAGS_PRESUMPTIVE_NO_PAYLOAD = 0x2, 						   // mgsvtpp.exe!141bdc498 // info & 0x200
        DATA_CHUNK_FLAGS_UNKNOWN1 = 0x20,              						   // mgsvtpp.exe!141bdc863, 141bd8041 // info >> 0xd, info & 0x2000
        DATA_CHUNK_FLAGS_PRESUMPTIVE_USE_FMDL_VERTEX_DATA = 0x80,              // mgsvtpp.exe!141bd7e30 // info & 0x8000
        DATA_CHUNK_FLAGS_UNKNOWN3 = 0x200,             						   // mgsvtpp.exe!141bdc7a7 // info >> 0x11
        DATA_CHUNK_FLAGS_UNKNOWN2 = 0x800,             						   // mgsvtpp.exe!141bdc830 // info >> 0x13
    } Flags : 16 <bgcolor=0x0080ff>;  // mgsvtpp.exe!141bdc492
	if (Flags & DATA_CHUNK_FLAGS_UNKNOWN1)
		Printf("A DataChunk %d has flag DATA_CHUNK_FLAGS_UNKNOWN1. Its functionality is unsupported.\n", SelfStartPos);
	if (Flags & DATA_CHUNK_FLAGS_UNKNOWN3)
		Printf("A DataChunk %d has flag DATA_CHUNK_FLAGS_UNKNOWN3. Its functionality is unsupported.\n", SelfStartPos);
	if (Flags & DATA_CHUNK_FLAGS_UNKNOWN2)
		Printf("A DataChunk %d has flag DATA_CHUNK_FLAGS_UNKNOWN2. Its functionality is unsupported.\n", SelfStartPos);

    ubyte EntryCount : 8 <bgcolor=0x0080ff>;
	BitfieldEnablePadding();

	uint NextBBDataChunkLinesOffset;

	uint Unknown0;
	uint NextIndexDataChunkLinesOffset;

	ReadCollisionFlags();

	uint Unknown2;
	uint VertexDataLinesOffset;
};

typedef struct
{
	local long SelfStartPos = FTell();

	DataChunkHeader Header;

	if (Header.Type == DATA_CHUNK_TYPE_BOUNDING_BOX) 
	{
        SetBackColor(COLOR_BOUNDINGBOXCHUNK);
        {
	        Float4 BoundingBoxRadii <bgcolor=0xDBC48F, comment="Width/2, Height/2, Depth/2">;
	        Float4 BoundingBoxCenter <bgcolor=0xDBC48F>;
        }
        SetBackColor(cNone);
	}
	else if (Header.Type == DATA_CHUNK_TYPE_INDICES)
	{
		local uint i;
	    for (i = 0; i < Header.EntryCount; i++)
	    {
			struct
			{
				short Offset0;
				short Offset1;
				short Offset2;
				short Offset3;
				short Offset4; // Seemingly always negative.
			} IndexSet <read=Str("%d, %d, %d, %d, %d", this.Offset0, this.Offset1, this.Offset2, this.Offset3, this.Offset4)>;
	    }
		
		if ((Header.VertexDataLinesOffset & 0xfffffff) != 0)
		{
			FSeek(SelfStartPos + Header.VertexDataLinesOffset * 16);

			struct
			{
				uint VertexCount;
				uint VerticesIndexOffset;

				uint Unknown0Or1; Assert(Unknown0Or1 == 0 || Unknown0Or1 == 1);

				uint OriginIndex;

				int64 VertexDataOffset; // This gets patched at runtime to use a FMDL pointer.
				
				uint FmdlVertexDataOffset;

				uint Padding0 <hidden = true>; Assert(Padding0 == 0);
			} VertexDataHeader;

			// mgsvtpp.exe!141bd7e9c
			if ((Header.Flags & DATA_CHUNK_FLAGS_PRESUMPTIVE_USE_FMDL_VERTEX_DATA) == 0)
			{
				Float4 VertexData[VertexDataHeader.VertexCount];

				// origin = VertexData[VertexDataHeader.OriginIndex]
				// A: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset0] + origin
				// B: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset1] + origin
				// C: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset2] + origin
				// D: VertexData[VertexDataHeader.VerticesIndexOffset + IndexSet.Offset3] + origin
			}
			else if (VertexDataHeader.VertexDataOffset == 0 && false /* FMDL vertex pointer is null*/)
			{
				// A: float4(0, -10000, 0, 0)
				// B: float4(0, -10000, 1, 0)
				// C: float4(1, -10000, 1, 0)
				// D: float4(1, -10000, 0, 0)
			}
			else
			{
				// VertexData points to the VertexDataHeader.FmdlVertexDataOffset-adjusted fmdl data.
				// A: VertexData[IndexSet.Offset0]
				// B: VertexData[IndexSet.Offset1]
				// C: VertexData[IndexSet.Offset2]
				// D: VertexData[IndexSet.Offset3]
			}
		}
	}
    else
    {
        Assert(false, "Unknown DataChunk Type Detected!");
    }
} DataChunk <read=Str("%s, %d", EnumToString(this.Header.Type), this.Header.Flags)>;

struct EntryDataChunkDefinition
{
	local uint SelfStartPos = FTell();

	byte IsFinalEntry;

	byte DataChunkCount;
	ushort DataChunksTotalDataSize;
	
	ushort BoundingBoxOrSubverticesOffset0;
	ushort Padding0 <hidden = true>; Assert(Padding0 == 0);
	
	ushort BoundingBoxOrSubverticesOffset1;
	ushort Padding1 <hidden = true>; Assert(Padding1 == 0);
	
	uint VerticesOffset;
	uint FirstDataChunkOffset;
	uint NextSectionOffset;
	
	ReadCollisionFlags();
};

struct EntryDataSection
{
    local uint SelfStartPos;
    local uint i;
	local uint nextBBChunkPos;

    while(!ReadUByte())
	{
        SelfStartPos = FTell();

		EntryDataChunkDefinition Entry;

        FSeek(SelfStartPos + Entry.FirstDataChunkOffset);

		// I'm going to have to stare at this for longer to understand what the heck is going on here.
		struct
		{
			local uint64 ptrs[6];
			ptrs[0] = SelfStartPos + Entry.FirstDataChunkOffset;
			local uint j = 1;
			local uint j_minusOne;
			local int iteratorIndex = 0;
			local int iteratorIndex_minusOne;
			local uint64 ptr;

			do
			{
				ptr = ptrs[iteratorIndex];

				j_minusOne = j - 1;
				iteratorIndex_minusOne = iteratorIndex - 1;

				FSeek(ptr + 4);
				if (ReadUInt() != 0) // if (Data.Header.NextBBDataChunkLinesOffset != 0)
				{
					ptrs[j - 1] = ptr + ReadUInt() * 16;

					j_minusOne = j;
					iteratorIndex_minusOne = iteratorIndex;
				}
			
				j = j_minusOne;
				iteratorIndex = iteratorIndex_minusOne;
				FSeek(ptr);
				if ((ReadUInt() & 0x200) == 0) // if (Data.Header.Info.Flags & DATA_CHUNK_FLAGS_PRESUMPTIVE_NO_PAYLOAD == 0)
				{
					DataChunk Data;

					if (Data.Header.NextIndexDataChunkLinesOffset != 0)
					{
						if (true)
						{
							j = j_minusOne + 1;
							iteratorIndex = iteratorIndex_minusOne + 1;
							ptrs[j_minusOne] = ptr + Data.Header.NextIndexDataChunkLinesOffset * 16;
						}
					}
				}
			} while (j > 0);
		} DataChunks;

        FSeek(SelfStartPos + 32);
	};

	// Skip last "dummy" data chunk definition
    FSkip(32);
};

struct EntryMaterialsSection
{
	byte MagicByte <hidden=true>;
    Assert(MagicByte == 0);
	
	byte InfoTriplet[3] <comment="(Material Count+1, Material Count+1, 1).">;
    Assert(InfoTriplet[0] == InfoTriplet[1]);
    Assert(InfoTriplet[2] == 1);
	
    local uint i = 0;
    for (i = 0; i < (InfoTriplet[0] - 1); i++)
    {
		MtrCode32 MaterialNameHash;
		FSkip(8);
    }
};

enum GEOM_ENTRY_TYPE
{
	GEOM_ENTRY_TYPE_0 = 0,
	GEOM_ENTRY_TYPE_6 = 6,
};

struct EntryBVHSection
{
	local uint SelfStartPos = FTell();

	Float3 EntryBoundingBoxCorner; // Mysterious. mgsvtpp.exe!141b95c89

	ushort GridTotalDataSize;
	ushort DataChunkDefinitionsCount;

	Float3 EntryBoundingBoxExtents;

	uint NextSectionOffset;

	Float3 Vector;
	
	uint BlockCountX;
	uint BlockCountY;
	uint BlockCountZ;
	
	ReadCollisionFlags();
	
	struct
	{
		short NodeOffsets[BlockCountX * BlockCountY * BlockCountZ] <hidden = true>;

		local uint i;
		local uint j;
		for (i = 0; i < BlockCountX * BlockCountY * BlockCountZ; i++)
		{
			if (NodeOffsets[i] != -1)
			{
				FSeek(SelfStartPos + NodeOffsets[i]);

				struct
				{
					ushort EntryCount <hidden = true>;
					for (j = 0; j < EntryCount; j++)
						ushort DataChunkDefinitionIndex;
				} Node;
			}
			else
			{
				struct
				{
				} Node;
			}
		}
	} Nodes;
};

struct EntrySecondaryHeaderSection
{
	local uint SelfStartPos = FTell();

	StrCode32 UnusedHash0;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);
	
	GEOM_ENTRY_TYPE Type;
	Assert((SecondaryHeaderSection.Type == GEOM_ENTRY_TYPE_0) || (SecondaryHeaderSection.Type == GEOM_ENTRY_TYPE_6), "Unknown Entry section detected!");
	
    uint NextSectionOffset;
	
	uint RemainingEntryDataSize;
	
	uint64 Padding1<hidden=true>; Assert(Padding1 == 0);
	uint Padding2<hidden=true>; Assert(Padding2 == 0);

	uint UnusedOffset<hidden=true>; Assert(UnusedOffset == 0);
};

struct EntryHeaderSection
{
	local uint SelfStartPos = FTell();

    StrCode32 UnusedHash0;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);

	uint UnknownFlag0x10Or0x40; Assert(UnknownFlag0x10Or0x40 == 0x10 || UnknownFlag0x10Or0x40 == 0x40); // mgsvtpp.exe!141bef7fa

	uint64 Padding1<hidden=true>; Assert(Padding1 == 0);
	uint Padding2<hidden=true>; Assert(Padding2 == 0);
	
	uint NextSectionOffset; // Size of the header + padding
	
	int PreviousEntryOffset; // The value stored is positive, but it's for jumping backwards in list.
	
	uint NextEntryOffset; // Size of the entry + padding
}; // mgsvtpp.exe!14cd19a40

struct
{
	uint Version;
	uint FirstEntryOffset;
	uint FileSize;

	uint u1 <hidden=true>; Assert(u1 == 7050094);

	uint64 Padding0<hidden=true>; Assert(Padding0 == 0);

	StrCode32 UnusedHash0;
	StrCode32 UnusedHash1;
} Header <bgcolor=COLOR_HEADER>; // mgsvtpp!141bef7b2

local uint DefinitionStartPos = Header.FirstEntryOffset;
do
{
	FSeek(DefinitionStartPos);

	struct
	{
		local uint SelfStartPos = FTell();
		
		EntryHeaderSection HeaderSection;
		
		FSeek(HeaderSection.SelfStartPos + HeaderSection.NextSectionOffset);

		EntrySecondaryHeaderSection SecondaryHeaderSection;

		if (SecondaryHeaderSection.NextSectionOffset == 0)
			break;
		FSeek(SecondaryHeaderSection.SelfStartPos + SecondaryHeaderSection.NextSectionOffset);
		
		if (SecondaryHeaderSection.Type == GEOM_ENTRY_TYPE_0)
		{
			EntryBVHSection BVHSection<bgcolor=COLOR_ENTRYBVHSECTION>;
		
			FSeek(BVHSection.SelfStartPos + BVHSection.NextSectionOffset);
		}
		
		EntryDataSection EntryData<bgcolor=COLOR_CHUNK11>;
		
		EntryMaterialsSection Materials<bgcolor=COLOR_ENTRYMATERIALSECTION>;
	} CollisionDefinition <bgcolor=COLOR_ENTRY>;

	DefinitionStartPos += CollisionDefinition.HeaderSection.NextEntryOffset;
} while (CollisionDefinition.HeaderSection.NextEntryOffset != 0);
LittleEndian();

#define COLOR_HEADER 0xDFEFAA
#define COLOR_ENTRY 0x7DE39E
#define COLOR_ENTRYSUBSECTION1 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_ENTRYMATERIALSECTION 0xB9E8DD
#define COLOR_BOUNDINGBOXCHUNK 0xF7F205

typedef struct
{
    uint hash<format=hex>;
} StrCode32 <read=(hash)>;

typedef struct 
{
    uint hash<format=hex>;
} MtrCode32 <read=(hash)>;

typedef struct
{
	float x;
	float y;
	float z;
} Float3 <read=Str("(%g, %g, %g)", x, y, z)>;

typedef struct
{
	float x;
	float y;
	float z;
	float w;
} Float4 <read=Str("(%g, %g, %g, %g)", x, y, z, w)>;

void EntryCollisionFlag()
{
	uint64 CollisionFlags<format=binary, bgcolor=0xFF00FF, fgcolor=0x00FF00>;
}

enum <byte> DATA_CHUNK_TYPE
{
	DATA_CHUNK_TYPE_UNKNOWN_0 = 0,
	DATA_CHUNK_TYPE_UNKNOWN_1 = 1,
	DATA_CHUNK_TYPE_INDICES = 2,
	DATA_CHUNK_TYPE_UNKNOWN_3 = 3,
	DATA_CHUNK_TYPE_BOUNDING_BOX = 4,
	DATA_CHUNK_TYPE_UNKNOWN_5 = 5,
	DATA_CHUNK_TYPE_UNKNOWN_6 = 6,
	DATA_CHUNK_TYPE_UNKNOWN_7 = 7,
	DATA_CHUNK_TYPE_UNKNOWN_8 = 8,
	DATA_CHUNK_TYPE_UNKNOWN_11 = 11,
};

uint GetDataChunkDataPerEntrySize(DATA_CHUNK_TYPE type)
{
	switch (type)
	{
		case DATA_CHUNK_TYPE_UNKNOWN_0:
			return 0x30;
		case DATA_CHUNK_TYPE_UNKNOWN_1:
			return 0x30;
		case DATA_CHUNK_TYPE_INDICES:
			return 0xA;
		case DATA_CHUNK_TYPE_UNKNOWN_3:
			return 0x60;
		case DATA_CHUNK_TYPE_BOUNDING_BOX:
			return 0x20;
		case DATA_CHUNK_TYPE_UNKNOWN_5:
			return 0x80;
		case DATA_CHUNK_TYPE_UNKNOWN_6:
			return 0;
		case DATA_CHUNK_TYPE_UNKNOWN_7:
			return 0;
		case DATA_CHUNK_TYPE_UNKNOWN_8:
			return 0x8;
		case 9:
			break;
		case 10:
			break;
		case DATA_CHUNK_TYPE_UNKNOWN_11:
			return 0x10;
		default:
			break;
	}

	Assert(false);
	return -1;
}

struct SubVerticesChunk
{
	uint VertexCountPlusOne;

	if ( ( FTell() + (VertexCountPlusOne * 16) + 32 - 4 ) > Header.FileSize )
	{
		Printf("External geometry reference detected.");
		return;
	}
	
	uint UnknownUInts[3]; // Most often 1, 1 and 0
	
	local long CurrentPos = FTell();
	
	uint VertexOffset;
	FSeek( CurrentPos + VertexOffset );
	
	Float4 Vertices[VertexCountPlusOne - 1];
};

struct DataChunkHeader
{
	local uint SelfStartPos = FTell();

	BitfieldDisablePadding();
    DATA_CHUNK_TYPE Type : 4 <bgcolor=0x0080ff>;

	ubyte Padding0 : 4 <hidden = true>; Assert(Padding0 == 0);

    enum <ushort> DATA_CHUNK_FLAGS
    {
        DATA_CHUNK_FLAGS_PRESUMPTIVE_NO_PAYLOAD = 0x2, // mgsvtpp.exe!141bdc498 // info & 0x200
        DATA_CHUNK_FLAGS_UNKNOWN1 = 0x20,              // mgsvtpp.exe!141bdc863, 141bd8041 // info >> 0xd, info & 0x2000
        DATA_CHUNK_FLAGS_UNKNOWN4 = 0x80,              // mgsvtpp.exe!141bd7e30 // info & 0x8000
        DATA_CHUNK_FLAGS_UNKNOWN3 = 0x200,             // mgsvtpp.exe!141bdc7a7 // info >> 0x11
        DATA_CHUNK_FLAGS_UNKNOWN2 = 0x800,             // mgsvtpp.exe!141bdc830 // info >> 0x13
    } UnknownFlags : 16 <bgcolor=0x0080ff>;  // mgsvtpp.exe!141bdc492
	Assert
	(
		((UnknownFlags & DATA_CHUNK_FLAGS_PRESUMPTIVE_NO_PAYLOAD) == 0) && 
		((UnknownFlags & DATA_CHUNK_FLAGS_UNKNOWN1) == 0) &&
		((UnknownFlags & DATA_CHUNK_FLAGS_UNKNOWN4) == 0) &&
		//((UnknownFlags & DATA_CHUNK_FLAGS_UNKNOWN3) == 0) &&
		((UnknownFlags & DATA_CHUNK_FLAGS_UNKNOWN2) == 0)
	);

    ubyte EntryCount : 8 <bgcolor=0x0080ff>;
	BitfieldEnablePadding();

	uint NextBBDataChunkLinesOffset;

	uint Unknown0;
	uint NextIndexDataChunkLinesOffset;

	EntryCollisionFlag();

	uint Unknown2;
	uint VertexDataLinesOffset;
};

typedef struct
{
	local long SelfStartPos = FTell();

	DataChunkHeader Header;

	if (Header.Type == DATA_CHUNK_TYPE_BOUNDING_BOX) 
	{
        SetBackColor(COLOR_BOUNDINGBOXCHUNK);
        {
	        Float4 BoundingBoxRadii <bgcolor=0xDBC48F, comment="Width/2, Height/2, Depth/2">;
	        Float4 BoundingBoxCenter <bgcolor=0xDBC48F>;
        }
        SetBackColor(cNone);
	}
	else if (Header.Type == DATA_CHUNK_TYPE_INDICES)
	{
		local uint i;
	    for (i = 0; i < Header.EntryCount; i++)
	    {
			struct
			{
				short Offset0;
				short Offset1;
				short Offset2;
				short Offset3;
				short Offset4; // Seemingly always negative.
			} IndexSet <read=Str("%d, %d, %d, %d, %d", this.Offset0, this.Offset1, this.Offset2, this.Offset3, this.Offset4)>;
	    }
		
		if ((Header.VertexDataLinesOffset & 0xfffffff) != 0)
		{
			FSeek(SelfStartPos + Header.VertexDataLinesOffset * 16);

			struct
			{
				uint VertexLinesCount;
				uint QuadVerticesOffset;
				uint Unknown0;
				uint QuadOriginPositionOffset;
				uint PayloadOffset;
				FSkip(12);
			} VertexDataHeader;

			if ((Header.UnknownFlags & DATA_CHUNK_FLAGS_UNKNOWN4) == 0)
			{

			}
			else if (VertexDataHeader.VertexDataOffset == 0)
			{

			}
			else
			{
				Assert(false);
			}
		}
	}
    else
    {
        Assert(false, "Unknown DataChunk Type Detected!");
    }
} DataChunk <read=Str("%s, %d", EnumToString(this.Header.Type), this.Header.UnknownFlags)>;

struct ShortPairs
{
	short SS1;
	short SS2;
};

struct EntryDataChunkDefinition
{
	local uint SelfStartPos = FTell();

	byte IsFinalEntry;

	byte DataChunkCount;
	ushort TotalDataChunksSizeInBytes;
	
	ushort BoundingBoxOrSubverticesOffset;
	ushort Padding0 <hidden = true>; Assert(Padding0 == 0);
	
	ushort BoundingBoxOrSubverticesOffset;
	ushort Padding0 <hidden = true>; Assert(Padding0 == 0);
	
	uint SubverticesOffset;
	uint FirstDataChunkOffset;
	uint NextSectionOffset;
	
	EntryCollisionFlag();
};

struct EntryDataSection
{
    local uint SelfStartPos;
    local uint i;
	local uint nextBBChunkPos;

    while(!ReadUByte())
	{
        SelfStartPos = FTell();

		EntryDataChunkDefinition Entry;

        FSeek(SelfStartPos + Entry.FirstDataChunkOffset);

		// I'm going to have to stare at this for longer to understand what the heck is going on here.
		struct
		{
			local uint64 ptrs[6];
			ptrs[0] = SelfStartPos + Entry.FirstDataChunkOffset;
			local uint j = 1;
			local uint j_minusOne;
			local int iteratorIndex = 0;
			local int iteratorIndex_minusOne;
			local uint64 ptr;

			do
			{
				ptr = ptrs[iteratorIndex];

				j_minusOne = j - 1;
				iteratorIndex_minusOne = iteratorIndex - 1;

				FSeek(ptr + 4);
				if (ReadUInt() != 0) // if (Data.Header.NextBBDataChunkLinesOffset != 0)
				{
					ptrs[j - 1] = ptr + ReadUInt() * 16;

					j_minusOne = j;
					iteratorIndex_minusOne = iteratorIndex;
				}
			
				j = j_minusOne;
				iteratorIndex = iteratorIndex_minusOne;
				FSeek(ptr);
				if ((ReadUInt() & 0x200) == 0) // if (Data.Header.Info.UnknownFlags & DATA_CHUNK_FLAGS_PRESUMPTIVE_NO_PAYLOAD == 0)
				{
					DataChunk Data;

					if (Data.Header.NextIndexDataChunkLinesOffset != 0)
					{
						if (true)
						{
							j = j_minusOne + 1;
							iteratorIndex = iteratorIndex_minusOne + 1;
							ptrs[j_minusOne] = ptr + Data.Header.NextIndexDataChunkLinesOffset * 16;
						}
					}
				}
			} while (j > 0);
		} DataChunks;

        FSeek(SelfStartPos + 32);
	};

	// Skip last "dummy" data chunk definition
    FSkip(32);
};

struct EntryMaterialsSection
{
	byte MagicByte <hidden=true>;
    Assert(MagicByte == 0);
	
	byte InfoTriplet[3] <comment="(Material Count+1, Material Count+1, 1).">;
    Assert(InfoTriplet[0] == InfoTriplet[1]);
    Assert(InfoTriplet[2] == 1);
	
    local uint i = 0;
    for (i = 0; i < (InfoTriplet[0] - 1); i++)
    {
		MtrCode32 MaterialNameHash;
		FSkip(8);
    }
};

enum GEOM_SECTION_TYPE
{
	GEOM_SECTION_TYPE_0 = 0,
	GEOM_SECTION_TYPE_6 = 6,
};

struct EntrySubsection1
{
	local uint SelfStartPos = FTell();

	Float3 EntryBoundingBoxCorner;
	ushort ShortPairsTotalSizeInBytes;
	ushort Section2Count;
	Float3 EntryBoundingBoxExtents;
	uint NextSectionOffset;

	Float3 Vector;
	uint UI1;
	
	uint UI2;
	uint UI2;
	
	EntryCollisionFlag();
	
	// HWL are they actually pairs?
	ShortPairs Pairs[ShortPairsTotalSizeInBytes / sizeof(ShortPairs)];
};

struct EntrySecondaryHeaderSection
{
	local uint SelfStartPos = FTell();

	StrCode32 Hash1;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);
	
	GEOM_SECTION_TYPE Type;
	Assert((SecondaryHeaderSection.Type == GEOM_SECTION_TYPE_0) || (SecondaryHeaderSection.Type == GEOM_SECTION_TYPE_6), "Unknown Entry section detected!");
	
    uint NextSectionOffset;
	
	uint SizeOfRemainingEntryData;
};

struct EntryHeaderSection
{
	local uint SelfStartPos = FTell();

    StrCode32 UnusedHash0;
	
	uint Padding0<hidden=true>; Assert(Padding0 == 0);

	uint UnknownFlag; // mgsvtpp.exe!141bef7fa

	uint64 Padding1<hidden=true>; Assert(Padding1 == 0);
	uint Padding2<hidden=true>; Assert(Padding2 == 0);
	
	uint NextSectionOffset; // Size of the header + padding
	
	int PreviousEntryOffset; // The value stored is positive, but it's for jumping backwards in list.
	
	uint NextEntryOffset; // Size of the entry + padding
}; // mgsvtpp.exe!14cd19a40

struct
{
	uint Version;
	uint FirstEntryOffset;
	uint FileSize;

	uint u1 <hidden=true>; Assert(u1 == 7050094);

	uint64 Padding0<hidden=true>; Assert(Padding0 == 0);

	StrCode32 UnusedHash0;
	StrCode32 UnusedHash1;
} Header <bgcolor=COLOR_HEADER>; // mgsvtpp!141bef7b2

local uint DefinitionStartPos = Header.FirstEntryOffset;
do
{
	FSeek(DefinitionStartPos);

	struct
	{
		local uint SelfStartPos = FTell();
		
		EntryHeaderSection HeaderSection;
		
		FSeek(HeaderSection.SelfStartPos + HeaderSection.NextSectionOffset);

		EntrySecondaryHeaderSection SecondaryHeaderSection;

		if (SecondaryHeaderSection.NextSectionOffset == 0)
			break;
		FSeek(SecondaryHeaderSection.SelfStartPos + SecondaryHeaderSection.NextSectionOffset);
		
		if (SecondaryHeaderSection.Type == GEOM_SECTION_TYPE_0)
		{
			EntrySubsection1 Section1<bgcolor=COLOR_ENTRYSUBSECTION1>;
		
			FSeek(Section1.SelfStartPos + Section1.NextSectionOffset);
		}
		
		EntryDataSection EntryData<bgcolor=COLOR_CHUNK11>;
		
		EntryMaterialsSection Materials<bgcolor=COLOR_ENTRYMATERIALSECTION>;
	} CollisionDefinition <bgcolor=COLOR_ENTRY>;

	DefinitionStartPos += CollisionDefinition.HeaderSection.NextEntryOffset;
} while (CollisionDefinition.HeaderSection.NextEntryOffset != 0);
// https://github.com/oldbanana12/GeomsParser/blob/master/Geoms.cs

// =================
// | Version 3.6.4 |
// =================

LittleEndian();

#define COLOR_HEADER 0xDFEFAA
#define COLOR_SECTION2 0x7DE39E
#define COLOR_ENTRY2 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_SECTION3 0xB9E8DD
#define COLOR_BOUNDINGBOXCHUNK 0xF7F205

struct Float3
{
    float x;
    float y;
    float z;
};

struct Float4
{
    float x;
    float y;
    float z;
    float w;
};

struct Quad
{
	ushort indices[4];
};

// doing it this way so that we don't have to click twice in order to see the value.
void EntryCollisionFlag()
{
	uint64 collision_flags<bgcolor=0xFF00FF, fgcolor=0x00FF00, comment="64 flags of goodies!">;
}

struct SubVerticesChunk
{
	uint verticesCount;
	
	// HWL dirty (but necessary) hack so that we don't surpass the end of the file and the
	// template abruptly stops executing
	if ( ( FTell() + (verticesCount * 16) + 32 - 4 ) > header.FileSize )
	{
		Printf("WARNING: Vertices will surpass end of file, ignoring.\n");
		return;
	}
	
	uint unknown_params[3] <comment="Most often they are 1, 1 and 0.">;
	
	local long CurrentPos = FTell();
	
	uint offset_to_vertices;
	FSeek( CurrentPos + offset_to_vertices );
	
	Float4 vertices[verticesCount - 1];
};

struct FaceChunk
{
    local uint quadCount = (DataChunkID & 0xff000000) >> 24;
	
	// always zero, so skip 'em.
	FSkip(12);
	
	EntryCollisionFlag();
	uint second_flag<comment="Usually zero">;
	uint line_offset_to_vertices <comment="The amount of lines left until we hit the sub vertices chunk">;

    local uint _i;
    for (_i = 0; _i < quadCount; _i++)
    {
        Quad quadIndices;
		
		// note: this FSkip(2) skips two bytes that in some cases are "FF FF" and in
		// others "02 FE". i can't find any difference between those two thus far though.
        FSkip(2);
    }

    // 16-byte alignment
    if (FTell() % 16 != 0)
    {
        FSkip(16 - (FTell() % 16));
    }
	
	local long posBeforeVertices = FTell();
	
	// there's some cases where there isn't enough space for a
	// sub vertices chunk because there's only 2 lines of the
	// file left. this check makes sure we don't make a sub
	// vertices chunk if that happens (this doesn't work most
	// of the time though, but just ignore the error).
	if ( FTell() + 32 < header.FileSize )
	{
		// HWL a cleaner implementation of the sub vertices chunk, as of v3.6.3.
		// instead of checking if the number of vertices is too ridiculous, we
		// instead use the line_offset_to_vertices variable. then, the template
		// "snaps" to that sub vertices chunk, and after it's done, it returns
		// to the previous position.
		// note: this doesn't happen if the sub vertices chunk is right underneath
		// this face chunk.
		if (line_offset_to_vertices > 0)
		{
			local long subVerticesChunkStartPos = (Data.DataChunk_startPos + (line_offset_to_vertices * 16) );
			
			FSeek(subVerticesChunkStartPos);
			SubVerticesChunk subverticeschunk;
			
			// HWL very important check so that we don't accidently declare a new data chunk
			// inside the sub vertices section.
			if (subVerticesChunkStartPos != posBeforeVertices)
				// return to the previous position.
				FSeek(posBeforeVertices);
		}
	}
};

struct BoundingBoxChunk
{
	Printf("Bounding Box Chunk");
	Printf( " (0x%LX)\n",FTell() );
	
	uint unknown <comment="Maybe a multiplier/divisor?">;
	uint flag;
	uint always_4 <hidden=true>;
	EntryCollisionFlag();
	
	// always zero
	FSkip(8);
	
	local uint pCount<comment="Always 2"> = ( (DataChunkID >> 16) & 0x000000FF );
	Float4 boundingBox_size[pCount];
};

// HWL this is for reading the DataChunkID as two parts: count, and type
string DataChunkID_read(uint DataChunkID)
{
	string s;
	uint indices_count = (DataChunkID >> 24);
	uint countA = ( (DataChunkID >> 16) & 0x000000FF );
	uint ID_type = (DataChunkID & 0xFFFF);
	
	SPrintf(s, "Type: %d, CountA: %d, CountB: %d", ID_type, countA, indices_count);
	
	return s;
}

struct DataChunk
{
    uint DataChunkID<read=DataChunkID_read, bgcolor=0x0080ff>;
	local long DataChunk_startPos = FTell() - 4;

	// make sure we don't make any more headway in the data chunk if we've
	// clearly hit the end of the file.
	if ( FTell() + 32 < header.FileSize )
	{
		// spotted a weird case where a first wasn't 0x01020004, but it had
		// one bit that was the same in 0x01020004, so i'm adding that
		// to the check.
		if (DataChunkID == 0x01020004 || ( DataChunkID & 0x4 ) == 0x4 )
		{
			// I seperated this into another struct just so that we can
			// have some more pretty colors.
			BoundingBoxChunk boundingboxchunk<bgcolor=COLOR_BOUNDINGBOXCHUNK>;
		}
		else if ((DataChunkID & 0x00000002) == 0x00000002 && (DataChunkID & 0xff000000) != 0)
		{
			Printf("Index buffer");
			Printf( " (0x%LX)\n",FTell() );
			FaceChunk facechunk;
		}
	}
};

struct ShortPairs
{
	short SS1;
	short SS2;
};

struct GeomProp_Subsection1
{
	Float3 Vector;
	uint UI1;
	
	uint UI2;
	uint UI2;
	
	// the ps3 files with different endianness proves this is
	// an int64.
	EntryCollisionFlag();
	
    // JOEY: Huge guess: perhaps Section2Offset aka 'section1_endPointOffset' is the size of the byte pairs blob?
	// HWL taking a look through ps3 files again, turns out these are pairs of shorts, not bytes! but are they
	// actually pairs though?
    ShortPairs Pairs[geomprop.BytePairsCount / 4];
};

struct GeomProp_Subsection2_Parts
{
	// all these data types must be correct, they've been
	// compared to the ps3 counterparts that have different
	// endianness.
	FSkip(1);
	byte B1 <comment="Most common values are 3 and 5.">;
	ushort UnknownCount; // HWL: "Unknown counter"
	
	ushort offset_to_boundingBox_or_subvertices <comment="This offset is from the start of this part">;
	FSkip(2);
	
	ushort offset_to_boundingBox_or_subvertices <comment="This offset is also from the start of this part">;
	FSkip(2);
	
	uint offset_to_subvertices <comment="NOTE: this offset starts from the beginning of geom properties subsection2, and NOT this specific part">;
	uint offset_to_boundingBoxChunk;
	uint offset_till_endofsection;
	
	EntryCollisionFlag();
};

struct GeomProp_Subsection2
{
	if ( entrysettingssecondary.Flag == 0 )
		GeomProp_Subsection2_Parts GeomProp_subsection2parts[geomprop.Section2Count] <optimize=false>;
	else // entrysettingssecondary.flag == 6
	{
		// HWL this reads a section from a part without actually declaring the part itself,
		// cause that will be ugly (and that was the previous way of doing it). this is
		// still a bit ugly though, but less than before!
		local uint offset_till_endofsection = ReadUInt( FTell() + 20 );
		local uint num_of_parts = ( (offset_till_endofsection / 32) - 1);
		
		local uint curNum_of_parts = num_of_parts;
		while (curNum_of_parts > 0)
		{
			GeomProp_Subsection2_Parts GeomProp_subsection2parts;
			--curNum_of_parts;
		}
	}
};

struct GeomProp_Materials
{
	byte magic_byte <hidden=true>;
	
	// padding stuff.
	FSkip(3);
	FSkip(28);
	
	FSkip(1);
	
	// as far as i can tell byte_pair[0] and byte_pair[1] are the same.
	byte byte_pair[3] <comment="They are often 2, 2 and 1.">;
	local byte terminatorCount = byte_pair[0] - 1 - 1; // -1 because i1
														// always exists.
	local byte terminatorCountActive = terminatorCount;
	
	uint material_type <comment="Apparently an StrCode32 hash?">;
	FSkip(8);
	
	while ( terminatorCountActive > 0 )
	{
		// is what we're reading an actual number and
		// not just padding?
		if ( ReadUInt() != 0 )
		{
			uint material_type <comment="Apparently an StrCode32 hash?">;
			terminatorCountActive -= 1;
		}
		// if it is padding, then skip it.
		else FSkip(4);
	}
	
	// if we're finished with the int reading section, then keep
	// reading until we hit the first data chunk.
	while ( ReadUInt() == 0 )
		FSkip(4);
};

// this was previously known as Chunk10
struct GeomProperties
{
	if ( entrysettingssecondary.Flag == 0 )
	{
		local long geompropStartPos = FTell();
	
		Float3 P1;
		ushort BytePairsCount;
		ushort Section2Count;
		Float3 P2;
		uint Section2Offset;
		
		GeomProp_Subsection1 Section1<bgcolor=COLOR_ENTRY2>;
	
		FSeek(geompropStartPos + Section2Offset);
	}
	GeomProp_Subsection2 Section2<bgcolor=COLOR_CHUNK11>;
	GeomProp_Materials Materials<bgcolor=COLOR_SECTION3>;
};

struct EntrySettingsSecondary
{
    uint Hash1;
	
	// previous uint u2 is now also skipped because it's always zero.
    FSkip(4);
	
    uint Flag;
    uint NextSectionOffset;
	
	// i think it's a flag. but it's surely an int (or uint).
	// EDIT: after so long, i realized this is actually the size
	// of the remaining entry
	uint Size_of_remaining_entry;
};

struct EntrySettingsPrimary
{
    uint Hash1;
	
	// HWL there used to be uints here, but i skip them because they are
	// always always zero.
    FSkip(4);
    uint Flag;
    FSkip(4 + 4 + 4);
	
    uint NextSectionOffset; // Size of the header + padding
	
	// HWL these were not 2 shorts after all, but an int.
	// thanks, ps3 files!
	int NegativePreviousEntryOffset;
	
    uint NextEntryOffset; // Size of the entry + padding
};

struct Entry
{
	local long startOfEntry = FTell();
	local long entryPosition = FTell();
	
	EntrySettingsPrimary entrysettingsprimary;

    entryPosition += entrysettingsprimary.NextSectionOffset;
    FSeek(entryPosition);
    EntrySettingsSecondary entrysettingssecondary;

    // No more sections in the entry
    if (entrysettingssecondary.NextSectionOffset == 0)
        break;

    // Next section
    entryPosition += entrysettingssecondary.NextSectionOffset;
	FSeek(entryPosition);

	if (entrysettingssecondary.Flag == 0)
	{
		GeomProperties geomprop;
	}
	else if (entrysettingssecondary.Flag == 6)
	{
		GeomProperties geomprop;
		
		// HWL updated after replacing the ugly hack with a less ugly hack
		entryPosition += geomprop.Section2.GeomProp_subsection2parts[0].offset_to_boundingBoxChunk;
		FSeek(entryPosition);
	}
	
    else
    {
        Assert(false, "Unknown Entry section detected!");
    }
	
	local long dataChunksStartPos = FTell();
	local long endOfEntry = startOfEntry + entrysettingsprimary.NextEntryOffset;


	local long bytesRemaining =
		entrysettingsprimary.NextEntryOffset == 0
		? header.FileSize - dataChunksStartPos
		: endOfEntry - dataChunksStartPos;

    local long dataStartPosition = FTell();
	
	// changed the != to a > , because in rare cases the bytesRemaining would be negative.
	// i think this newer fix doesn't need that anymore though, but i'm leaving it just in
	// case.
    while (bytesRemaining > 0)
    {
        DataChunk Data;
        bytesRemaining -= FTell() - dataStartPosition;
        dataStartPosition = FTell();
    }
};

struct Header
{
    uint Version;
    uint Size;
    uint FileSize;

    uint u1;
    Assert(u1 == 7050094);

    uint u2 <hidden=true>;
    uint u3 <hidden=true>;
   
    Assert(u2 == 0);
    Assert(u3 == 0);

    uint Hash1;
    uint Hash2;
} header <bgcolor=COLOR_HEADER>;

local long startPosition = header.Size;
local long nextEntry = -1;

while (nextEntry != 0)
{
    startPosition = FTell();
    Entry entry <bgcolor=COLOR_SECTION2>;
    nextEntry = entry.entrysettingsprimary.NextEntryOffset;

    FSeek(startPosition + nextEntry);
}
// https://github.com/oldbanana12/GeomsParser/blob/master/Geoms.cs

// =================
// | Version 3.6.6 |
// =================

LittleEndian();

#define COLOR_HEADER 0xDFEFAA
#define COLOR_SECTION2 0x7DE39E
#define COLOR_ENTRY2 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_SECTION3 0xB9E8DD
#define COLOR_BOUNDINGBOXCHUNK 0xF7F205

struct StrCode32
{
    uint hash;
};

struct MtrHash
{
    uint hash;
};

struct Float3
{
	float x;
	float y;
	float z;
};

struct Float4
{
	float x;
	float y;
	float z;
	float w;
};

struct Quad
{
	ushort indices[4];
};

void EntryCollisionFlag()
{
	uint64 CollisionFlags<bgcolor=0xFF00FF, fgcolor=0x00FF00>;
}

struct SubVerticesChunk
{
	uint verticesCount;
	
	// HWL dirty (but necessary) hack so that we don't surpass the end of the file and the
	// template abruptly stops executing
	if ( ( FTell() + (verticesCount * 16) + 32 - 4 ) > header.FileSize )
	{
		Printf("WARNING: Vertices will surpass end of file, ignoring.\n");
		return;
	}
	
	uint unknown_params[3] <comment="Most often they are 1, 1 and 0.">;
	
	local long CurrentPos = FTell();
	
	uint offset_to_vertices;
	FSeek( CurrentPos + offset_to_vertices );
	
	Float4 vertices[verticesCount - 1];
};

struct FaceChunk
{
	local uint quadCount = (DataChunkID & 0xff000000) >> 24;
	
	// always zero, so skip 'em.
	FSkip(12);
	
	EntryCollisionFlag();
	uint second_flag<comment="Usually zero">;
	uint line_offset_to_vertices <comment="The amount of lines left until we hit the sub vertices chunk">;

	local uint _i;
	for (_i = 0; _i < quadCount; _i++)
	{
		Quad quadIndices;
		
		// note: this FSkip(2) skips two bytes that in some cases are "FF FF" and in
		// others "02 FE". i can't find any difference between those two thus far though.
		FSkip(2);
	}

	// 16-byte alignment
	if (FTell() % 16 != 0)
	{
		FSkip(16 - (FTell() % 16));
	}
	
	local long posBeforeVertices = FTell();
	
	// HWL removed a very old if check as of v3.6.5.

	// HWL a cleaner implementation of the sub vertices chunk, as of v3.6.3.
	// instead of checking if the number of vertices is too ridiculous, we
	// instead use the line_offset_to_vertices variable. then, the template
	// "snaps" to that sub vertices chunk, and after it's done, it returns
	// to the previous position.
	// note: this doesn't happen if the sub vertices chunk is right underneath
	// this face chunk.
	if (line_offset_to_vertices > 0)
	{
		local long subVerticesChunkStartPos = (Data.DataChunk_startPos + (line_offset_to_vertices * 16) );
		
		FSeek(subVerticesChunkStartPos);
		SubVerticesChunk subverticeschunk;
		
		// HWL very important check so that we don't accidently declare a new data chunk
		// inside the sub vertices section.
		if (subVerticesChunkStartPos != posBeforeVertices)
			// return to the previous position.
			FSeek(posBeforeVertices);
	}
};

struct BoundingBoxChunk
{
	Printf("Bounding Box Chunk");
	Printf( " (0x%LX)\n",FTell() );
	
	uint linesOffsetNextDataChunk <comment="Number of lines left until next DataChunk (FaceChunk excluded). For the first DataChunk of a Section it's always 0">;
	uint flag;
	uint always_4 <hidden=true>;
	EntryCollisionFlag();
	
	// always zero
	FSkip(8);
	
	// Thanks to Jinmar for figuring out that the center transform is what 
	// the second Float4 is used for!
	Float4 boundingBoxSize <bgcolor=0xDBC48F, comment="Width/2, Height/2, Depth/2">;
	Float4 boundingBoxPivotCenter <bgcolor=0xDBC48F, comment="Pivot Center">;
};

// ===============================================
// Functions for properly reading the DataChunkID.
// ===============================================
ushort DataChunkID_readType(uint DataChunkID)
{
	return DataChunkID & 0xFF; // This basically reads the uint's first byte.
}

// HWL this is for reading the DataChunkID as four parts: countA, countB, type,
// and an unknown count (the second byte).
string DataChunkID_read(uint DataChunkID)
{
	string s;
	uint indices_count = (DataChunkID >> 24);
	uint countA = ( (DataChunkID >> 16) & 0x000000FF );
	
	uint ID_type = DataChunkID_readType(DataChunkID);
	uint second_unknown_ID_type = ( (DataChunkID & 0xFF00) >> 8); // This is the second byte
	// in the uint.
	
	SPrintf(s, "Type: %d, CountA: %d, CountB: %d, Unknown: %d", ID_type, countA, indices_count, second_unknown_ID_type);
	
	return s;
}
// =================
// End of functions.
// =================

struct DataChunk
{
	uint DataChunkID<read=DataChunkID_read, bgcolor=0x0080ff>;
	
	local long DataChunk_startPos = FTell() - 4;

	// make sure we don't make any more headway in the data chunk if we've
	// clearly hit the end of the file.
	if ( FTell() + 32 < header.FileSize )
	{
		// HWL This got updated after so long!
		if (DataChunkID_readType(DataChunkID) == 4) // type 4 is for bounding boxes
		{
			// I seperated this into another struct just so that we can
			// have some more pretty colors.
			BoundingBoxChunk boundingboxchunk<bgcolor=COLOR_BOUNDINGBOXCHUNK>;
		}
		// HWL This also got updated, as of v3.6.5. No more messy bit shifts!
		else if (DataChunkID_readType(DataChunkID) == 2)
		{
			Printf("Index buffer");
			Printf( " (0x%LX)\n",FTell() );
			FaceChunk facechunk;
		}
		else if ( (DataChunkID >> 16) == 0) // are CountA and CountB zero?
		{
			haltDataChunks = 1;
		}
	}
};

struct ShortPairs
{
	short SS1;
	short SS2;
};

struct EntrySubsection2Entry
{
	byte IsFinalEntry;

	byte SectionOffset <comment="Nb of DataChunks until next Section.">;
	ushort BytesPerSection <comment="Nb of bytes per Section, Data[0] next Section - Data[0] current Section.">;
	
	ushort OffsetToBoundingBoxOrSubvertices <comment="This offset is from the start of this part">;
	FSkip(2);
	
	ushort OffsetToBoundingBoxOrSubvertices <comment="This offset is also from the start of this part">;
	FSkip(2);
	
	uint OffsetToSubvertices <comment="NOTE: this offset starts from the beginning of geom properties subsection2, and NOT this specific part">;
	uint OffsetToBoundingBoxChunk;
	uint NextSectionOffset;
	
	EntryCollisionFlag();
};

struct EntrySubsection2
{
	while(!ReadUByte())
	{
		EntrySubsection2Entry Subsection2Entry;
	}

	FSkip(32);
};

struct EntryMaterialsSection
{
	byte MagicByte <hidden=true>;
    Assert(MagicByte == 0);
	
	byte InfoTriplet[3] <comment="(Material Count+1, Material Count+1, 1).">;
    Assert(InfoTriplet[0] == InfoTriplet[1]);
    Assert(InfoTriplet[2] == 1);
	
    local uint i = 0;
    for (i = 0; i < (InfoTriplet[0] - 1); i++)
    {
		MtrHash MaterialNameHash;
		FSkip(8);
    }

	// Align to nearest 16-byte boundary, then skip 32 more bytes.
	FSeek(((FTell() - 1) | 15) + 1);
	FSkip(32);
};

enum GEOM_SECTION_TYPE
{
	GEOM_SECTION_TYPE_0 = 0,
	GEOM_SECTION_TYPE_6 = 6,
};

struct EntrySubsection1
{
	Float3 EntryBoundingBoxCorner;
	ushort ShortPairsTotalSizeInBytes;
	ushort Section2Count;
	Float3 EntryBoundingBoxExtents;
	uint Section2Offset;

	Float3 Vector;
	uint UI1;
	
	uint UI2;
	uint UI2;
	
	EntryCollisionFlag();
	
	// HWL are they actually pairs?
	ShortPairs Pairs[ShortPairsTotalSizeInBytes / sizeof(ShortPairs)];
};

struct EntrySecondaryHeaderSection
{
	StrCode32 Hash1;
	
	Assert(ReadUInt() == 0);
	FSkip(4);
	
	GEOM_SECTION_TYPE Type;
	Assert((entrySecondaryHeaderSection.Type == GEOM_SECTION_TYPE_0) || (entrySecondaryHeaderSection.Type == GEOM_SECTION_TYPE_6), "Unknown Entry section detected!");
	
    uint NextSectionOffset;
	
	uint EntryDataSize;
};

struct EntryHeaderSection
{
    StrCode32 Hash1;
	
	Assert(ReadUInt() == 0);
	FSkip(4);
	uint Flag;
	Assert(ReadUInt64() == 0);
	FSkip(8);
	Assert(ReadUInt() == 0);
	FSkip(4);
	
	uint SecondaryHeaderOffset; // Size of the header + padding
	
	int NegativePreviousEntryOffset;
	
	uint NextEntryOffset; // Size of the entry + padding
};

struct Entry
{
	local long entryStartPosition = FTell();
	local long entryRelativePosition = FTell();
	
	// HWL Used for the last section of an entry that can have
	// empty sub vertex chunks. the template freaks out if this
	// isn't implemented
	local byte haltDataChunks = 0;
	
	EntryHeaderSection entryHeaderSection;

	entryRelativePosition += entryHeaderSection.SecondaryHeaderOffset;
	FSeek(entryRelativePosition);
	EntrySecondaryHeaderSection entrySecondaryHeaderSection;

	// No more sections in the entry
	if (entrySecondaryHeaderSection.NextSectionOffset == 0)
		break;

	// Next section
	entryRelativePosition += entrySecondaryHeaderSection.NextSectionOffset;
	FSeek(entryRelativePosition);
	
	if (entrySecondaryHeaderSection.Type == GEOM_SECTION_TYPE_0)
	{
		EntrySubsection1 Section1<bgcolor=COLOR_ENTRY2>;
	
		// Next section
		entryRelativePosition += Section1.Section2Offset;
		FSeek(entryRelativePosition);
	}
	
	EntrySubsection2 Section2<bgcolor=COLOR_CHUNK11>;
	EntryMaterialsSection Materials<bgcolor=COLOR_SECTION3>;
	
	local long dataChunksStartPos = FTell();
	local long endOfEntry = entryStartPosition + entryHeaderSection.NextEntryOffset;


	local long bytesRemaining =
		entryHeaderSection.NextEntryOffset == 0
		? header.FileSize - dataChunksStartPos
		: endOfEntry - dataChunksStartPos;

	local long dataStartPosition = FTell();
	
	// changed the != to a > , because in rare cases the bytesRemaining would be negative.
	// i think this newer fix doesn't need that anymore though, but i'm leaving it just in
	// case.
	while (bytesRemaining > 0 && haltDataChunks == 0)
	{
		DataChunk Data;
		bytesRemaining -= FTell() - dataStartPosition;
		dataStartPosition = FTell();
	}
};

struct Header
{
	uint Version;
	uint Size;
	uint FileSize;

	uint u1 <hidden=true>;
	Assert(u1 == 7050094);

	Assert(ReadUInt64() == 0);
	FSkip(8);

	StrCode32 Hash1;
	StrCode32 Hash2;
} header <bgcolor=COLOR_HEADER>;

local long startPosition = header.Size;
local long nextEntry = -1;

while (nextEntry != 0)
{
	startPosition = FTell();
	Entry entry <bgcolor=COLOR_SECTION2>;
	nextEntry = entry.entryHeaderSection.NextEntryOffset;

	FSeek(startPosition + nextEntry);
}
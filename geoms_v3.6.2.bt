// https://github.com/oldbanana12/GeomsParser/blob/master/Geoms.cs

// =============================================================================
// Updated version of Joey's "geom+geoms" modification of geoms_v3.5.2 template.
// =============================================================================

LittleEndian();

#define COLOR_HEADER 0xDFEFAA
#define COLOR_SECTION2 0x7DE39E
#define COLOR_ENTRY2 0x00AAFF
#define COLOR_CHUNK11 0xAED2E8
#define COLOR_SECTION3 0xB9E8DD
#define COLOR_BIZARREINT64STRUCT 0xCF85FF
#define COLOR_POSITIONCHUNK 0xF7F205

struct Float3
{
    float x;
    float y;
    float z;
};

struct Float4
{
    float x;
    float y;
    float z;
    float w;
};

struct Quad
{
	ushort indices[4];
};

struct BizarreInt64Struct
{
	uint64 maybe_flags <comment="This one is definitely related to player collision.">;
	uint maybe_another_flag <comment="Not related to collision as far as i can tell.">;
	uint some_count <comment="Sometimes it can be quadCount - 1. Touching this can crash the game!">;
};

struct SubVerticesChunk
{
	uint verticesCount;
	uint unknown_params[3] <comment="Most often they are 1, 1 and 0.">;
	
	local long CurrentPos = FTell();
	
	uint offset_to_vertices;
	FSeek( CurrentPos + offset_to_vertices );
	
	Float4 vertices[verticesCount-1];
};

struct FaceChunk
{
    local uint quadCount = (DataChunkID & 0xff000000) >> 24;
	
	// always zero, so skip 'em.
	FSkip(12);
	
	BizarreInt64Struct bizarreint64struct <bgcolor=COLOR_BIZARREINT64STRUCT>;

    local uint _i;
    for (_i = 0; _i < quadCount; _i++)
    {
        Quad quadIndices;
		
		// note: this FSkip(2) skips two bytes that in some cases are "FF FF" and in
		// others "02 FE". i can't find any difference between those two thus far though.
        FSkip(2);
    }

    // 16-byte alignment
    if (FTell() % 16 != 0)
    {
        FSkip(16 - (FTell() % 16));
    }
	
	// there's some cases where there isn't enough space for a
	// sub vertices chunk because there's only 2 lines of the
	// file left. this check makes sure we don't make a sub
	// vertices chunk if that happens (this doesn't work most
	// of the time though, but just ignore the error).
	if ( FTell() + 32 < header.FileSize )
	{
		// dirty hack: check if the number of vertices is way too
		// ridiculous to be true. if it's normal, then it's surely a
		// vertices count.
		if ( (ReadUInt() & 0xFFFF0000) == 0x0 )
		{
			SubVerticesChunk subverticeschunk;
		}
	}
};

struct PositionChunk
{
	Printf("Position chunk");
	Printf( " (0x%LX)\n",FTell() );
	
	uint some_num;
	uint some_num2;
	uint maybe_flag;
	BizarreInt64Struct bizarreint64struct <bgcolor=COLOR_BIZARREINT64STRUCT>;
	
	Float4 p1;
	Float4 p2;
};

struct DataChunk
{
    uint DataChunkID;

	// make sure we don't make any more headway in the data chunk if we've
	// clearly hit the end of the file.
	if ( FTell() + 32 < header.FileSize )
	{
		// spotted a weird case where a first wasn't 0x01020004, but it had
		// one bit that was the same in 0x01020004, so i'm adding that
		// to the check.
		if (DataChunkID == 0x01020004 || ( DataChunkID & 0x4 ) == 0x4 )
		{
			// I seperated this into another struct just so that we can
			// have some more pretty colors.
			PositionChunk positionchunk <bgcolor=COLOR_POSITIONCHUNK>;
		}
		else if ((DataChunkID & 0x00000002) == 0x00000002 && (DataChunkID & 0xff000000) != 0)
		{
			Printf("Index buffer");
			Printf( " (0x%LX)\n",FTell() );
			FaceChunk facechunk;
		}
	}
};

struct BytePairs
{
	byte SB1;
	byte SB2;
};

// the continuation of Chunk10
struct Chunk10_Subsection1
{
	Float3 Vector;
	uint UI1;
	
	uint UI2;
	uint UI2;
	
	// the ps3 files with different endianness proves this is
	// an int64.
	int64 L1;
	
    // JOEY: Huge guess: perhaps Section2Offset aka 'section1_endPointOffset' is the size of the byte pairs blob?
    BytePairs Pairs[chunk10.BytePairsCount / 2];
};

struct Chunk10_Subsection2_Parts
{
	// all these data types must be correct, they've been
	// compared to the ps3 counterparts that have different
	// endianness.
	FSkip(1);
	byte B1;
	ushort UnknownCount; // HWL: "Unknown counter"
	
	ushort US2;
	FSkip(2);
	
	ushort US3;
	FSkip(2);
	
	int I1;
	int dataChunkoffset;
	uint offset_till_endofsection;
	
	uint64 UI64 <comment="Maybe a flag?">;
};

struct Chunk10_Subsection2
{
	if ( chunk0.Flag == 0 ) Chunk10_Subsection2_Parts chunk10subsection2parts[chunk10.Section2Count] <optimize=false>;
	else // chunk0.flag == 6
	{
		// VERY UGLY HACK: use the offset_till_endofsection of the first part to see how many more (parts) there are.
		
		Chunk10_Subsection2_Parts chunk10subsection2part_first;
		
		// get the offset_till_endofsection and divide it by 32 (32 = the size of each part). then, subtract
		// 1 since we already declared one part and then subtract 1 again just so that we have the right number!
		local uint remaining_subsection2parts = (chunk10subsection2part_first.offset_till_endofsection / 32) - 1 - 1;
		Chunk10_Subsection2_Parts chunk10subsection2parts[remaining_subsection2parts] <optimize=false>;
	}
};

struct Chunk10_Subsection3
{
	byte magic_byte;
	
	// padding stuff.
	FSkip(3);
	FSkip(28);
	
	FSkip(1);
	
	// as far as i can tell byte_pair1[0] and byte_pair1[1] are the same.
	byte byte_pair1[3] <comment="They are often 2, 2 and 1.">;
	local byte terminatorCount = byte_pair1[0] - 1 - 1; // -1 because i1
														// always exists.
	local byte terminatorCountActive = terminatorCount;
	
	int i1;
	FSkip(8);
	
	while ( terminatorCountActive > 0 )
	{
		// is what we're reading an actual number and
		// not just padding?
		if ( ReadUInt() != 0 )
		{
			int i;
			terminatorCountActive -= 1;
		}
		// if it is padding, then skip it.
		else FSkip(4);
	}
	
	// if we're finished with the int reading section, then keep
	// reading until we hit the first data chunk.
	if ( terminatorCountActive == 0 )
	{
		while ( ReadUInt() == 0 ) FSkip(4);
	}
};
struct Chunk10
{
	if ( chunk0.Flag == 0 )
	{
		local long chunk10StartPos = FTell();
	
		Float3 P1;
		ushort BytePairsCount;
		ushort Section2Count;
		Float3 P2;
		uint Section2Offset;
		
		Chunk10_Subsection1 Section1<bgcolor=COLOR_ENTRY2>;
	
		FSeek(chunk10StartPos + Section2Offset);
	}
	Chunk10_Subsection2 Section2<bgcolor=COLOR_CHUNK11>;
	Chunk10_Subsection3 Section3<bgcolor=COLOR_SECTION3>;
};

struct Chunk0
{
    uint Hash1;
    uint u2;
    uint Flag;
    uint NextSectionOffset;
	
	// i think it's a flag. but it's surely an int (or uint).
	uint Flag2;
};

struct Entry
{
	local long startOfEntry = FTell();
	local long entryPosition = FTell();
	
    uint Hash1;
    uint u2;
    uint Flag;
    uint u4;
    uint u5;
    uint u6;
    uint NextSectionOffset; // Size of the header + padding
    ushort u8a;
    short u8b;
    uint NextEntryOffset; // Size of the entry + padding

    entryPosition += NextSectionOffset;
    FSeek(entryPosition);
    Chunk0 chunk0;

    // No more sections in the entry
    if (chunk0.NextSectionOffset == 0)
        break;

    // Next section
    entryPosition += chunk0.NextSectionOffset;
	FSeek(entryPosition);

	if (chunk0.Flag == 0)
	{
		Chunk10 chunk10;
	}
	else if (chunk0.Flag == 6)
	{
		Chunk10 chunk10;
		
		entryPosition += chunk10.Section2.chunk10subsection2part_first.dataChunkoffset;
		FSeek(entryPosition);
	}
	
    else
    {
        Assert(false, "Unknown Entry section detected!");
    }
	
	local long dataChunksStartPos = FTell();
	local long endOfEntry = startOfEntry + NextEntryOffset;


	local long bytesRemaining =
		NextEntryOffset == 0
		? header.FileSize - dataChunksStartPos
		: endOfEntry - dataChunksStartPos;

    local long dataStartPosition = FTell();
	
	// changed the != to a > , because in rare cases the bytesRemaining would be negative.
	// i think this newer fix doesn't need that anymore though, but i'm leaving it just in
	// case.
    while (bytesRemaining > 0)
    {
        DataChunk Data;
        bytesRemaining -= FTell() - dataStartPosition;
        dataStartPosition = FTell();
    }
};

struct Header
{
    uint Version;
    uint Size;
    uint FileSize;

    uint u1;
    Assert(u1 == 7050094);

    uint u2 <hidden=true>;
    uint u3 <hidden=true>;
   
    Assert(u2 == 0);
    Assert(u3 == 0);

    uint Hash1;
    uint Hash2;
} header <bgcolor=COLOR_HEADER>;

local long startPosition = header.Size;
local long nextEntry = -1;

while (nextEntry != 0)
{
    startPosition = FTell();
    Entry entry <bgcolor=COLOR_SECTION2>;
    nextEntry = entry.NextEntryOffset;

    FSeek(startPosition + nextEntry);
}
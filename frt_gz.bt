//------------------------------------------------
// Note: Values hardcoded from e20020_area.frt
//------------------------------------------------
LittleEndian();

struct Vector4
{
    float x;
    float y;
    float z;
    float w;
};

struct Divisor
{
    short x;
    short y;
    short z;
    short w;
};

enum <ubyte> RouteAimTargetType
{
    ROUTE_AIM_NO_TARGET = 0,
    ROUTE_AIM_STATIC_POINT = 1,
    ROUTE_AIM_CHARACTER = 2,
    ROUTE_AIM_ROUTE_AS_SIGHT_MOVE_PATH = 3,
    ROUTE_AIM_ROUTE_AS_OBJECT = 4
};

struct Vector3
{
    float x;
    float y;
    float z;
};

char ROUT[4] <bgcolor=0xFCE7A3>;

struct Header
{
    ushort version;

    if (version == 512)
    {
        BigEndian();
    }

    ushort routeCount;
    
    FSkip(8); //Irrelevant memory leak bytes
	
    Vector4 origin;

    uint routeIdsOffset;
    uint routeDefinitionsOffset;
    uint nodesOffset;
    uint eventTablesOffset;
    uint eventsOffset;
    uint fileSize;
    
    FSkip(8); //Irrelevant memory leak bytes
} header <bgcolor=0x85C426>;

local int routeIdsPosition = FTell();
local int i = 0;

struct Route
{
	//Get route id first for Jump to Template Variable
	FSeek(routeIdsPosition + ( 0x4 * i ) );
	uint routeId <bgcolor=0x8F9032>;
	//Offset to the start of current route definitions
	FSeek(routeIdsPosition + ( header.routeCount * 0x4 ) + ( 0x10 * i ) );
    local int routeDefinitionsPosition = FTell();
	
    uint nodesOffset;
    uint eventTableOffset;
    uint eventsOffset;
    ushort nodeCount;
    ushort eventCount;

    // Maps nodes to events
    FSeek(routeDefinitionsPosition + eventTableOffset);
    struct EventTable
    {
        ushort eventCount;
        ushort eventIndex;
    } eventTables[nodeCount];
	
    FSeek(routeDefinitionsPosition + eventsOffset);
    struct Event
    {
        uint type;
		ubyte isNodeEvent;
		RouteAimTargetType aimPointType;
		ubyte flagA <hidden = true>; Assert(flagA == 0);
		ubyte flagB;
		
		ushort time; //A common wait time is 479 or 299.
		short dir; //Counter-clockwise from 0 to ushort max, in Unity looking at blue Z

		byte u0; Assert(u0==-1||u0==0);
		byte u1 <hidden = true>; Assert(u1==0);
		byte u2 <hidden = true>; Assert(u2==0);
		byte u3 <hidden = true>; Assert(u3==0);
		
		if (aimPointType == ROUTE_AIM_NO_TARGET)
		{
			uint unknown0 <hidden = true>; Assert(unknown0==0);
			uint unknown1 <hidden = true>; Assert(unknown1==0);
			uint unknown2 <hidden = true>; Assert(unknown2==0);
			uint unknown3 <hidden = true>; Assert(unknown3==0);
			
			uint unknown4;
			uint unknown5;
			uint unknown6;
			uint unknown7;
		}
		else if (aimPointType == ROUTE_AIM_STATIC_POINT)
		{
			Vector3 aimPos;
			uint unknown3 <hidden = true>; Assert(unknown3==0);
			
			uint unknown4;
			int unknown5;
			uint unknown6 <hidden = true>; Assert(unknown6==0);
			uint unknown7 <hidden = true>; Assert(unknown7==0);
		}
		else if (aimPointType == ROUTE_AIM_CHARACTER)
		{
			uint64 characterId;
			uint unknown2 <hidden = true>; Assert(unknown2==0);
			uint unknown3 <hidden = true>; Assert(unknown3==0);
			
			uint unknown4;
			uint unknown5;
			uint unknown6;
			uint unknown7 <hidden = true>; Assert(unknown7==0);
		}
		else if (aimPointType == ROUTE_AIM_ROUTE_AS_SIGHT_MOVE_PATH)
		{
			uint sightRouteId;
			Vector3 aimPos;
			
			uint unknown4;
			uint unknown5 <hidden = true>; Assert(unknown5==0);
			uint unknown6 <hidden = true>; Assert(unknown6==0);
			uint unknown7 <hidden = true>; Assert(unknown7==0);
		}
		else if (aimPointType == ROUTE_AIM_ROUTE_AS_OBJECT)
		{
			uint objectId;
			Vector3 aimPos;
			
			uint unknown4 <hidden = true>; Assert(unknown4==0);
			uint unknown5 <hidden = true>; Assert(unknown5==0);
			uint unknown6 <hidden = true>; Assert(unknown6==0);
			uint unknown7 <hidden = true>; Assert(unknown7==0);
		}
		else
		{
			Assert(2+2==5,"Unknown aimpointtype!!!");
		}
		
    } events[eventCount] <optimize=false>;

    FSeek(routeDefinitionsPosition + nodesOffset);
	struct Node
	{
		uint64 coordinate;
	} nodes[nodeCount] <bgcolor=0x01062F>;
	
	i++;
	FSeek(routeIdsPosition + ( 0x4 * i ) ); //Reset to next start position so Jump to Template Variable works on hashes
} route[header.routeCount] <bgcolor=0x413A55, fgcolor=0xFFFFFF, optimize=false>;